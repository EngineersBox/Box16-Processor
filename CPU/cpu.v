/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module DIG_RAMDualAccess
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
    input C, // Clock signal
    input ld,
    input [(AddrBits-1):0] \1A ,
    input [(AddrBits-1):0] \2A ,
    input [(Bits-1):0] \1Din ,
    input str,
    output [(Bits-1):0] \1D ,
    output [(Bits-1):0] \2D
);
    // CAUTION: uses distributed RAM
    reg [(Bits-1):0] memory [0:((1 << AddrBits)-1)];

    assign \1D = ld? memory[\1A ] : 'hz;
    assign \2D = memory[\2A ];

    always @ (posedge C) begin
        if (str)
            memory[\1A ] <= \1Din ;
    end

endmodule



module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module Demux3
(
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    output out_4,
    output out_5,
    output out_6,
    output out_7,
    input [2:0] sel,
    input in
);
    assign out_0 = (sel == 3'h0)? in : 'd0;
    assign out_1 = (sel == 3'h1)? in : 'd0;
    assign out_2 = (sel == 3'h2)? in : 'd0;
    assign out_3 = (sel == 3'h3)? in : 'd0;
    assign out_4 = (sel == 3'h4)? in : 'd0;
    assign out_5 = (sel == 3'h5)? in : 'd0;
    assign out_6 = (sel == 3'h6)? in : 'd0;
    assign out_7 = (sel == 3'h7)? in : 'd0;
endmodule


module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module high_mask_in (
  input [15:0] D_HIGH,
  input [15:0] D,
  input EN,
  output [15:0] Q
);
  wire [15:0] s0;
  assign s0[7:0] = D[7:0];
  assign s0[15:8] = D_HIGH[7:0];
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i0 (
    .sel( EN ),
    .in_0( D_HIGH ),
    .in_1( s0 ),
    .out( Q )
  );
endmodule

module Mux_8x1_NBits #(
    parameter Bits = 2
)
(
    input [2:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule


module reg_file (
  input [2:0] RS1, // The index of the register which should output its value to OUT1.
  input [2:0] RS2, // The index of the register which should output its value to OUT2.
  input [2:0] WS, // The index of the register which should save the value on IN on the next clock cycle (if WE is high).
  input WE, // Whether the register selected by WS should save the value from IN on the next cycle.
  input [15:0] IN, // The value to be saved into the register specified by WS if WE is high,
  input clk,
  input [15:0] FL_IN, // The value to be saved into the register specified by WS if WE is high,
  input FL_EN, // Whether the register selected by WS should save the value from IN on the next cycle.
  input [15:0] PC_IN,
  input HE,
  output [15:0] OUT1, // The value in the register specified by RS1.
  output [15:0] OUT2, // The value in the register specified by RS2.
  output [15:0] PC_S,
  output PC_WE,
  output [15:0] FL_OUT
);
  wire s0;
  wire [15:0] s1;
  wire [15:0] s2;
  wire s3;
  wire [15:0] s4;
  wire [15:0] s5;
  wire s6;
  wire [15:0] s7;
  wire [15:0] s8;
  wire s9;
  wire [15:0] s10;
  wire [15:0] s11;
  wire s12;
  wire [15:0] s13;
  wire [15:0] FL_OUT_temp;
  wire s14;
  wire PC_WE_temp;
  wire [15:0] s15;
  wire s16;
  wire [15:0] s17;
  wire [15:0] s18;
  Demux3 Demux3_i0 (
    .sel( WS ),
    .in( WE ),
    .out_0( s0 ),
    .out_1( s3 ),
    .out_2( s6 ),
    .out_3( s9 ),
    .out_4( s12 ),
    .out_5( s14 ),
    .out_7( PC_WE_temp )
  );
  // RZ
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i1 (
    .D( 16'b0 ),
    .C( clk ),
    .en( s0 ),
    .Q( s1 )
  );
  assign s16 = (s14 | FL_EN);
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i2 (
    .sel( PC_WE_temp ),
    .in_0( PC_IN ),
    .in_1( IN ),
    .out( s18 )
  );
  high_mask_in high_mask_in_i3 (
    .D_HIGH( s18 ),
    .D( PC_IN ),
    .EN( HE ),
    .Q( s17 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i4 (
    .sel( PC_WE_temp ),
    .in_0( 16'b0 ),
    .in_1( s17 ),
    .out( PC_S )
  );
  // R1
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i5 (
    .D( s2 ),
    .C( clk ),
    .en( s3 ),
    .Q( s4 )
  );
  // R2
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i6 (
    .D( s5 ),
    .C( clk ),
    .en( s6 ),
    .Q( s7 )
  );
  // R3
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i7 (
    .D( s8 ),
    .C( clk ),
    .en( s9 ),
    .Q( s10 )
  );
  // R4
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i8 (
    .D( s11 ),
    .C( clk ),
    .en( s12 ),
    .Q( s13 )
  );
  Mux_8x1_NBits #(
    .Bits(16)
  )
  Mux_8x1_NBits_i9 (
    .sel( RS1 ),
    .in_0( s1 ),
    .in_1( s4 ),
    .in_2( s7 ),
    .in_3( s10 ),
    .in_4( s13 ),
    .in_5( FL_OUT_temp ),
    .in_6( 16'b0 ),
    .in_7( PC_IN ),
    .out( OUT1 )
  );
  Mux_8x1_NBits #(
    .Bits(16)
  )
  Mux_8x1_NBits_i10 (
    .sel( RS2 ),
    .in_0( s1 ),
    .in_1( s4 ),
    .in_2( s7 ),
    .in_3( s10 ),
    .in_4( s13 ),
    .in_5( FL_OUT_temp ),
    .in_6( 16'b0 ),
    .in_7( PC_IN ),
    .out( OUT2 )
  );
  // FL
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i11 (
    .D( s15 ),
    .C( clk ),
    .en( s16 ),
    .Q( FL_OUT_temp )
  );
  high_mask_in high_mask_in_i12 (
    .D_HIGH( IN ),
    .D( s4 ),
    .EN( HE ),
    .Q( s2 )
  );
  high_mask_in high_mask_in_i13 (
    .D_HIGH( IN ),
    .D( s7 ),
    .EN( HE ),
    .Q( s5 )
  );
  high_mask_in high_mask_in_i14 (
    .D_HIGH( IN ),
    .D( s10 ),
    .EN( HE ),
    .Q( s8 )
  );
  high_mask_in high_mask_in_i15 (
    .D_HIGH( IN ),
    .D( s13 ),
    .EN( HE ),
    .Q( s11 )
  );
  high_mask_in high_mask_in_i16 (
    .D_HIGH( FL_IN ),
    .D( FL_OUT_temp ),
    .EN( HE ),
    .Q( s15 )
  );
  assign PC_WE = PC_WE_temp;
  assign FL_OUT = FL_OUT_temp;
endmodule

module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule

module LUT_OpcodeCL (
    input \0 ,
    input \1 ,
    input \2 ,
    input \3 ,
    output reg  [12:0]  out
);
    reg [12:0] my_lut [0:15];
    wire [3:0] temp;
    assign temp = {\3 , \2 , \1 , \0 };

    always @ (*) begin
       out = my_lut[temp];
    end

    initial begin
        my_lut[0] = 13'h28;
        my_lut[1] = 13'h1028;
        my_lut[2] = 13'h0;
        my_lut[3] = 13'h0;
        my_lut[4] = 13'h4cc;
        my_lut[5] = 13'h534;
        my_lut[6] = 13'h0;
        my_lut[7] = 13'h0;
        my_lut[8] = 13'hda0;
        my_lut[9] = 13'hda1;
        my_lut[10] = 13'hda2;
        my_lut[11] = 13'hda3;
        my_lut[12] = 13'h0;
        my_lut[13] = 13'h0;
        my_lut[14] = 13'h0;
        my_lut[15] = 13'h0;
    end
endmodule


module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module control_unit (
  input [15:0] INST,
  input FL_Z,
  output [1:0] ALUOP,
  output [2:0] RS1,
  output [2:0] RS2,
  output [2:0] WS,
  output STR,
  output WE,
  output [1:0] DMUX,
  output LDR,
  output FL_EN,
  output HE
);
  wire [2:0] s0;
  wire [2:0] s1;
  wire [2:0] s2;
  wire [3:0] s3;
  wire s4;
  wire s5;
  wire s6;
  wire s7;
  wire [12:0] s8;
  wire [1:0] s9;
  wire [2:0] s10;
  wire [1:0] s11;
  wire [2:0] s12;
  wire [1:0] s13;
  wire [1:0] s14;
  wire s15;
  wire s16;
  wire s17;
  wire s18;
  wire s19;
  wire s20;
  assign s20 = (~ INST[11] | FL_Z);
  assign s0 = INST[10:8];
  assign s1 = INST[6:4];
  assign s2 = INST[2:0];
  assign s3 = INST[15:12];
  Mux_2x1_NBits #(
    .Bits(3)
  )
  Mux_2x1_NBits_i0 (
    .sel( s20 ),
    .in_0( 3'b0 ),
    .in_1( s0 ),
    .out( WS )
  );
  assign s4 = s3[0];
  assign s5 = s3[1];
  assign s6 = s3[2];
  assign s7 = s3[3];
  // OpcodeCL
  LUT_OpcodeCL LUT_OpcodeCL_i1 (
    .\0 ( s4 ),
    .\1 ( s5 ),
    .\2 ( s6 ),
    .\3 ( s7 ),
    .out( s8 )
  );
  assign s13 = s8[1:0];
  assign s14 = s8[3:2];
  assign s15 = s8[4];
  assign s16 = s8[5];
  assign s17 = s8[6];
  assign s11 = s8[8:7];
  assign s9 = s8[10:9];
  assign s18 = s8[11];
  assign s19 = s8[12];
  Mux_4x1_NBits #(
    .Bits(3)
  )
  Mux_4x1_NBits_i2 (
    .sel( s9 ),
    .in_0( 3'b0 ),
    .in_1( s0 ),
    .in_2( s1 ),
    .in_3( s2 ),
    .out( s10 )
  );
  Mux_4x1_NBits #(
    .Bits(3)
  )
  Mux_4x1_NBits_i3 (
    .sel( s11 ),
    .in_0( 3'b0 ),
    .in_1( s0 ),
    .in_2( s1 ),
    .in_3( s2 ),
    .out( s12 )
  );
  Mux_2x1 Mux_2x1_i4 (
    .sel( s20 ),
    .in_0( 1'b0 ),
    .in_1( s18 ),
    .out( FL_EN )
  );
  Mux_2x1 Mux_2x1_i5 (
    .sel( s20 ),
    .in_0( 1'b0 ),
    .in_1( s17 ),
    .out( STR )
  );
  Mux_2x1 Mux_2x1_i6 (
    .sel( s20 ),
    .in_0( 1'b0 ),
    .in_1( s16 ),
    .out( WE )
  );
  Mux_2x1 Mux_2x1_i7 (
    .sel( s20 ),
    .in_0( 1'b0 ),
    .in_1( s15 ),
    .out( LDR )
  );
  Mux_2x1_NBits #(
    .Bits(2)
  )
  Mux_2x1_NBits_i8 (
    .sel( s20 ),
    .in_0( 2'b0 ),
    .in_1( s14 ),
    .out( DMUX )
  );
  Mux_2x1_NBits #(
    .Bits(2)
  )
  Mux_2x1_NBits_i9 (
    .sel( s20 ),
    .in_0( 2'b0 ),
    .in_1( s13 ),
    .out( ALUOP )
  );
  Mux_2x1 Mux_2x1_i10 (
    .sel( s20 ),
    .in_0( 1'b0 ),
    .in_1( s19 ),
    .out( HE )
  );
  Mux_2x1_NBits #(
    .Bits(3)
  )
  Mux_2x1_NBits_i11 (
    .sel( s20 ),
    .in_0( 3'b0 ),
    .in_1( s10 ),
    .out( RS1 )
  );
  Mux_2x1_NBits #(
    .Bits(3)
  )
  Mux_2x1_NBits_i12 (
    .sel( s20 ),
    .in_0( 3'b0 ),
    .in_1( s12 ),
    .out( RS2 )
  );
endmodule

module CompSigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = $signed(a) > $signed(b);
    assign \= = $signed(a) == $signed(b);
    assign \< = $signed(a) < $signed(b);
endmodule


module ripple_carry_adder_overflow (
  input [15:0] A,
  input [15:0] B,
  input C_in,
  output [15:0] Q,
  output C_out,
  output V
);
  wire [14:0] s0;
  wire [14:0] s1;
  wire [14:0] s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire C_out_temp;
  assign s0 = A[14:0];
  assign s4 = A[15];
  assign s1 = B[14:0];
  assign s5 = B[15];
  DIG_Add #(
    .Bits(15)
  )
  DIG_Add_i0 (
    .a( s0 ),
    .b( s1 ),
    .c_i( C_in ),
    .s( s2 ),
    .c_o( s3 )
  );
  DIG_Add #(
    .Bits(1)
  )
  DIG_Add_i1 (
    .a( s4 ),
    .b( s5 ),
    .c_i( s3 ),
    .s( s6 ),
    .c_o( C_out_temp )
  );
  assign Q[14:0] = s2;
  assign Q[15] = s6;
  assign V = (C_out_temp ^ s3);
  assign C_out = C_out_temp;
endmodule

module alu (
  input [15:0] A, // First input to ALU
  input [15:0] B, // Second input to ALU
  input [1:0] ALUOP, // Operation selection input
  output [15:0] RESULT, // The result of this ALU operation
  output [3:0] FLAG // The flags associated with the result of this ALU operation
                    // 
                    // 0. Z (zero)
                    // 1. N (negative)
                    // 2. C (carry)
                    // 3. V (overflow)

);
  wire [15:0] RESULT_temp;
  wire [15:0] s0;
  wire s1;
  wire [15:0] s2;
  wire [15:0] s3;
  wire [15:0] s4;
  wire [15:0] s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  wire s10;
  wire C_out;
  wire V;
  assign s0 = ~ B;
  CompSigned #(
    .Bits(2)
  )
  CompSigned_i0 (
    .a( 2'b1 ),
    .b( ALUOP ),
    .\= ( s1 )
  );
  assign s10 = ALUOP[1];
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i1 (
    .sel( s1 ),
    .in_0( B ),
    .in_1( s0 ),
    .out( s2 )
  );
  assign s3 = (A | s2);
  assign s5 = (A & s2);
  ripple_carry_adder_overflow ripple_carry_adder_overflow_i2 (
    .A( A ),
    .B( s2 ),
    .C_in( s1 ),
    .Q( s4 ),
    .C_out( C_out ),
    .V( V )
  );
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i3 (
    .sel( ALUOP ),
    .in_0( s4 ),
    .in_1( s4 ),
    .in_2( s5 ),
    .in_3( s3 ),
    .out( RESULT_temp )
  );
  Mux_2x1 Mux_2x1_i4 (
    .sel( s10 ),
    .in_0( C_out ),
    .in_1( 1'b0 ),
    .out( s8 )
  );
  Mux_2x1 Mux_2x1_i5 (
    .sel( s10 ),
    .in_0( V ),
    .in_1( 1'b0 ),
    .out( s9 )
  );
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i6 (
    .a( RESULT_temp ),
    .b( 16'b0 ),
    .\= ( s6 ),
    .\< ( s7 )
  );
  assign FLAG[0] = s6;
  assign FLAG[1] = s7;
  assign FLAG[2] = s8;
  assign FLAG[3] = s9;
  assign RESULT = RESULT_temp;
endmodule

module cpu (
  input CLK
);
  wire STR;
  wire LDR;
  wire [15:0] s0;
  wire [15:0] s1;
  wire [15:0] s2;
  wire [15:0] s3;
  wire [15:0] s4;
  wire [15:0] s5;
  wire [15:0] s6;
  wire [2:0] RS1;
  wire [2:0] RS2;
  wire [2:0] WS;
  wire WE;
  wire [15:0] s7;
  wire [15:0] s8;
  wire FL_EN;
  wire HE;
  wire [15:0] s9;
  wire s10;
  wire [15:0] s11;
  wire [1:0] DMUX;
  wire [15:0] s12;
  wire [15:0] s13;
  wire s14;
  wire [1:0] ALUOP;
  wire [3:0] s15;
  // RAM
  DIG_RAMDualAccess #(
    .Bits(16),
    .AddrBits(16)
  )
  DIG_RAMDualAccess_i0 (
    .str( STR ),
    .C( CLK ),
    .ld( LDR ),
    .\1A ( s0 ),
    .\1Din ( s1 ),
    .\2A ( s2 ),
    .\1D ( s3 ),
    .\2D ( s4 )
  );
  // PC
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i1 (
    .D( s5 ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( s2 )
  );
  // +1
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i2 (
    .a( 16'b1 ),
    .b( s2 ),
    .c_i( 1'b0 ),
    .s( s6 )
  );
  reg_file reg_file_i3 (
    .RS1( RS1 ),
    .RS2( RS2 ),
    .WS( WS ),
    .WE( WE ),
    .IN( s7 ),
    .clk( CLK ),
    .FL_IN( s8 ),
    .FL_EN( FL_EN ),
    .PC_IN( s2 ),
    .HE( HE ),
    .OUT1( s0 ),
    .OUT2( s1 ),
    .PC_S( s9 ),
    .PC_WE( s10 ),
    .FL_OUT( s11 )
  );
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i4 (
    .sel( DMUX ),
    .in_0( s12 ),
    .in_1( s3 ),
    .in_2( s13 ),
    .in_3( 16'b0 ),
    .out( s7 )
  );
  control_unit control_unit_i5 (
    .INST( s4 ),
    .FL_Z( s14 ),
    .ALUOP( ALUOP ),
    .RS1( RS1 ),
    .RS2( RS2 ),
    .WS( WS ),
    .STR( STR ),
    .WE( WE ),
    .DMUX( DMUX ),
    .LDR( LDR ),
    .FL_EN( FL_EN ),
    .HE( HE )
  );
  alu alu_i6 (
    .A( s0 ),
    .B( s1 ),
    .ALUOP( ALUOP ),
    .RESULT( s12 ),
    .FLAG( s15 )
  );
  assign s13[7:0] = s4[7:0];
  assign s13[15:8] = 8'b0;
  assign s8[3:0] = s15;
  assign s8[15:4] = 12'b0;
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i7 (
    .sel( s10 ),
    .in_0( s6 ),
    .in_1( s9 ),
    .out( s5 )
  );
  assign s14 = s11[0];
endmodule

-- generated by Digital. Don't modify this file!
-- Any changes will be lost if this file is regenerated.

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity DIG_RAMDualAccess is
  generic (
    Bits : integer;       
    AddrBits : integer ); 
  port (
    n1D: out std_logic_vector ((Bits-1) downto 0);
    n2D: out std_logic_vector ((Bits-1) downto 0);
    str: in std_logic;
    C: in std_logic;
    ld: in std_logic;
    n1A: in std_logic_vector ((AddrBits-1) downto 0);
    n1Din: in std_logic_vector ((Bits-1) downto 0);
    n2A: in std_logic_vector ((AddrBits-1) downto 0) );
end DIG_RAMDualAccess;

architecture Behavioral of DIG_RAMDualAccess is
    -- CAUTION: uses distributed RAM
    type memoryType is array(0 to (2**AddrBits)-1) of STD_LOGIC_VECTOR((Bits-1) downto 0);
    signal memory : memoryType;
begin
  process ( C )
  begin
    if rising_edge(C) AND (str='1') then
      memory(to_integer(unsigned(n1A))) <= n1Din;
    end if;
  end process;
  n1D <= memory(to_integer(unsigned(n1A))) when ld='1' else (others => 'Z');
  n2D <= memory(to_integer(unsigned(n2A)));
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_Register_BUS is
  generic ( Bits: integer ); 
  port (
    Q: out std_logic_vector ((Bits-1) downto 0);
    D: in std_logic_vector ((Bits-1) downto 0);
    C: in std_logic;
    en: in std_logic );
end DIG_Register_BUS;

architecture Behavioral of DIG_Register_BUS is
  signal state : std_logic_vector ((Bits-1) downto 0) := (others => '0');
begin
   Q <= state;

   process ( C )
   begin
      if rising_edge(C) and (en='1') then
        state <= D;
      end if;
   end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;

entity DIG_Add is
  generic ( Bits: integer ); 
  port (
    s: out std_logic_vector((Bits-1) downto 0);
    c_o: out std_logic;
    a: in std_logic_vector((Bits-1) downto 0);
    b: in std_logic_vector((Bits-1) downto 0);
    c_i: in std_logic );
end DIG_Add;

architecture Behavioral of DIG_Add is
   signal temp : std_logic_vector(Bits downto 0);
begin
   temp <= ('0' & a) + b + c_i;

   s    <= temp((Bits-1) downto 0);
   c_o  <= temp(Bits);
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DEMUX_GATE_3 is
  port (
    out_0: out std_logic;
    out_1: out std_logic;
    out_2: out std_logic;
    out_3: out std_logic;
    out_4: out std_logic;
    out_5: out std_logic;
    out_6: out std_logic;
    out_7: out std_logic;
    sel: in std_logic_vector (2 downto 0);
    p_in: in std_logic );
end DEMUX_GATE_3;

architecture Behavioral of DEMUX_GATE_3 is
begin
    out_0 <= p_in when sel = "000" else '0';
    out_1 <= p_in when sel = "001" else '0';
    out_2 <= p_in when sel = "010" else '0';
    out_3 <= p_in when sel = "011" else '0';
    out_4 <= p_in when sel = "100" else '0';
    out_5 <= p_in when sel = "101" else '0';
    out_6 <= p_in when sel = "110" else '0';
    out_7 <= p_in when sel = "111" else '0';
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_1 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic;
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_1;

architecture Behavioral of MUX_GATE_BUS_1 is
begin
  with sel select
    p_out <=
      in_0 when '0',
      in_1 when '1',
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity high_mask_in is
  port (
    D_HIGH: in std_logic_vector(15 downto 0);
    D: in std_logic_vector(15 downto 0);
    EN: in std_logic;
    Q: out std_logic_vector(15 downto 0));
end high_mask_in;

architecture Behavioral of high_mask_in is
  signal s0: std_logic_vector(15 downto 0);
begin
  s0(7 downto 0) <= D(7 downto 0);
  s0(15 downto 8) <= D_HIGH(7 downto 0);
  gate0: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => EN,
      in_0 => D_HIGH,
      in_1 => s0,
      p_out => Q);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_3 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic_vector (2 downto 0);
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0);
    in_2: in std_logic_vector ((Bits-1) downto 0);
    in_3: in std_logic_vector ((Bits-1) downto 0);
    in_4: in std_logic_vector ((Bits-1) downto 0);
    in_5: in std_logic_vector ((Bits-1) downto 0);
    in_6: in std_logic_vector ((Bits-1) downto 0);
    in_7: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_3;

architecture Behavioral of MUX_GATE_BUS_3 is
begin
  with sel select
    p_out <=
      in_0 when "000",
      in_1 when "001",
      in_2 when "010",
      in_3 when "011",
      in_4 when "100",
      in_5 when "101",
      in_6 when "110",
      in_7 when "111",
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity reg_file is
  port (
    RS1: in std_logic_vector(2 downto 0); -- The index of the register which should output its value to OUT1.
    RS2: in std_logic_vector(2 downto 0); -- The index of the register which should output its value to OUT2.
    WS: in std_logic_vector(2 downto 0); -- The index of the register which should save the value on IN on the next clock cycle (if WE is high).
    WE: in std_logic; -- Whether the register selected by WS should save the value from IN on the next cycle.
    p_IN: in std_logic_vector(15 downto 0); -- The value to be saved into the register specified by WS if WE is high,
    clk: in std_logic;
    FL_IN: in std_logic_vector(15 downto 0); -- The value to be saved into the register specified by WS if WE is high,
    FL_EN: in std_logic; -- Whether the register selected by WS should save the value from IN on the next cycle.
    PC_IN: in std_logic_vector(15 downto 0);
    HE: in std_logic;
    OUT1: out std_logic_vector(15 downto 0); -- The value in the register specified by RS1.
    OUT2: out std_logic_vector(15 downto 0); -- The value in the register specified by RS2.
    PC_S: out std_logic_vector(15 downto 0);
    PC_WE: out std_logic;
    FL_OUT: out std_logic_vector(15 downto 0));
end reg_file;

architecture Behavioral of reg_file is
  signal s0: std_logic;
  signal s1: std_logic_vector(15 downto 0);
  signal s2: std_logic_vector(15 downto 0);
  signal s3: std_logic;
  signal s4: std_logic_vector(15 downto 0);
  signal s5: std_logic_vector(15 downto 0);
  signal s6: std_logic;
  signal s7: std_logic_vector(15 downto 0);
  signal s8: std_logic_vector(15 downto 0);
  signal s9: std_logic;
  signal s10: std_logic_vector(15 downto 0);
  signal s11: std_logic_vector(15 downto 0);
  signal s12: std_logic;
  signal s13: std_logic_vector(15 downto 0);
  signal FL_OUT_temp: std_logic_vector(15 downto 0);
  signal s14: std_logic;
  signal PC_WE_temp: std_logic;
  signal s15: std_logic_vector(15 downto 0);
  signal s16: std_logic;
  signal s17: std_logic_vector(15 downto 0);
  signal s18: std_logic_vector(15 downto 0);
begin
  gate0: entity work.DEMUX_GATE_3
    port map (
      sel => WS,
      p_in => WE,
      out_0 => s0,
      out_1 => s3,
      out_2 => s6,
      out_3 => s9,
      out_4 => s12,
      out_5 => s14,
      out_7 => PC_WE_temp);
  gate1: entity work.DIG_Register_BUS -- RZ
    generic map (
      Bits => 16)
    port map (
      D => "0000000000000000",
      C => clk,
      en => s0,
      Q => s1);
  s16 <= (s14 OR FL_EN);
  gate2: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => PC_WE_temp,
      in_0 => PC_IN,
      in_1 => p_IN,
      p_out => s18);
  gate3: entity work.high_mask_in
    port map (
      D_HIGH => s18,
      D => PC_IN,
      EN => HE,
      Q => s17);
  gate4: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => PC_WE_temp,
      in_0 => "0000000000000000",
      in_1 => s17,
      p_out => PC_S);
  gate5: entity work.DIG_Register_BUS -- R1
    generic map (
      Bits => 16)
    port map (
      D => s2,
      C => clk,
      en => s3,
      Q => s4);
  gate6: entity work.DIG_Register_BUS -- R2
    generic map (
      Bits => 16)
    port map (
      D => s5,
      C => clk,
      en => s6,
      Q => s7);
  gate7: entity work.DIG_Register_BUS -- R3
    generic map (
      Bits => 16)
    port map (
      D => s8,
      C => clk,
      en => s9,
      Q => s10);
  gate8: entity work.DIG_Register_BUS -- R4
    generic map (
      Bits => 16)
    port map (
      D => s11,
      C => clk,
      en => s12,
      Q => s13);
  gate9: entity work.MUX_GATE_BUS_3
    generic map (
      Bits => 16)
    port map (
      sel => RS1,
      in_0 => s1,
      in_1 => s4,
      in_2 => s7,
      in_3 => s10,
      in_4 => s13,
      in_5 => FL_OUT_temp,
      in_6 => "0000000000000000",
      in_7 => PC_IN,
      p_out => OUT1);
  gate10: entity work.MUX_GATE_BUS_3
    generic map (
      Bits => 16)
    port map (
      sel => RS2,
      in_0 => s1,
      in_1 => s4,
      in_2 => s7,
      in_3 => s10,
      in_4 => s13,
      in_5 => FL_OUT_temp,
      in_6 => "0000000000000000",
      in_7 => PC_IN,
      p_out => OUT2);
  gate11: entity work.DIG_Register_BUS -- FL
    generic map (
      Bits => 16)
    port map (
      D => s15,
      C => clk,
      en => s16,
      Q => FL_OUT_temp);
  gate12: entity work.high_mask_in
    port map (
      D_HIGH => p_IN,
      D => s4,
      EN => HE,
      Q => s2);
  gate13: entity work.high_mask_in
    port map (
      D_HIGH => p_IN,
      D => s7,
      EN => HE,
      Q => s5);
  gate14: entity work.high_mask_in
    port map (
      D_HIGH => p_IN,
      D => s10,
      EN => HE,
      Q => s8);
  gate15: entity work.high_mask_in
    port map (
      D_HIGH => p_IN,
      D => s13,
      EN => HE,
      Q => s11);
  gate16: entity work.high_mask_in
    port map (
      D_HIGH => FL_IN,
      D => FL_OUT_temp,
      EN => HE,
      Q => s15);
  PC_WE <= PC_WE_temp;
  FL_OUT <= FL_OUT_temp;
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_2 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic_vector (1 downto 0);
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0);
    in_2: in std_logic_vector ((Bits-1) downto 0);
    in_3: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_2;

architecture Behavioral of MUX_GATE_BUS_2 is
begin
  with sel select
    p_out <=
      in_0 when "00",
      in_1 when "01",
      in_2 when "10",
      in_3 when "11",
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
use IEEE.NUMERIC_STD.ALL;

entity DIG_LUT_OpcodeCL is
  port (
    n0: in std_logic;
    n1: in std_logic;
    n2: in std_logic;
    n3: in std_logic;

    p_out: out std_logic_vector (12 downto 0)
);
end DIG_LUT_OpcodeCL;

architecture Behavioral of DIG_LUT_OpcodeCL is
  type mem is array ( 0 to 15) of std_logic_vector (12 downto 0);
  constant my_lut : mem := (
    "0000000101000", "1000000101000", "0000000000000", "0000000000000", 
    "0010011001100", "0010100110100", "0000000000000", "0000000000000", 
    "0110110100000", "0110110100001", "0110110100010", "0110110100011", 
    "0000000000000", "0000000000000", "0000000000000", "0000000000000"
    );
  signal temp : std_logic_vector(3 downto 0);
begin
  temp <= n3 & n2 & n1 & n0;
  p_out <= my_lut(to_integer(unsigned(temp)));
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_1 is
  port (
    p_out: out std_logic;
    sel: in std_logic;
    
    in_0: in std_logic;
    in_1: in std_logic );
end MUX_GATE_1;

architecture Behavioral of MUX_GATE_1 is
begin
  with sel select
    p_out <=
      in_0 when '0',
      in_1 when '1',
      '0' when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity control_unit is
  port (
    INST: in std_logic_vector(15 downto 0);
    FL_Z: in std_logic;
    ALUOP: out std_logic_vector(1 downto 0);
    RS1: out std_logic_vector(2 downto 0);
    RS2: out std_logic_vector(2 downto 0);
    WS: out std_logic_vector(2 downto 0);
    STR: out std_logic;
    WE: out std_logic;
    DMUX: out std_logic_vector(1 downto 0);
    LDR: out std_logic;
    FL_EN: out std_logic;
    HE: out std_logic);
end control_unit;

architecture Behavioral of control_unit is
  signal s0: std_logic_vector(2 downto 0);
  signal s1: std_logic_vector(2 downto 0);
  signal s2: std_logic_vector(2 downto 0);
  signal s3: std_logic_vector(3 downto 0);
  signal s4: std_logic;
  signal s5: std_logic;
  signal s6: std_logic;
  signal s7: std_logic;
  signal s8: std_logic_vector(12 downto 0);
  signal s9: std_logic_vector(1 downto 0);
  signal s10: std_logic_vector(2 downto 0);
  signal s11: std_logic_vector(1 downto 0);
  signal s12: std_logic_vector(2 downto 0);
  signal s13: std_logic_vector(1 downto 0);
  signal s14: std_logic_vector(1 downto 0);
  signal s15: std_logic;
  signal s16: std_logic;
  signal s17: std_logic;
  signal s18: std_logic;
  signal s19: std_logic;
  signal s20: std_logic;
begin
  s20 <= (NOT INST(11) OR FL_Z);
  s0 <= INST(10 downto 8);
  s1 <= INST(6 downto 4);
  s2 <= INST(2 downto 0);
  s3 <= INST(15 downto 12);
  gate0: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 3)
    port map (
      sel => s20,
      in_0 => "000",
      in_1 => s0,
      p_out => WS);
  s4 <= s3(0);
  s5 <= s3(1);
  s6 <= s3(2);
  s7 <= s3(3);
  gate1: entity work.DIG_LUT_OpcodeCL -- OpcodeCL
    port map (
      n0 => s4,
      n1 => s5,
      n2 => s6,
      n3 => s7,
      p_out => s8);
  s13 <= s8(1 downto 0);
  s14 <= s8(3 downto 2);
  s15 <= s8(4);
  s16 <= s8(5);
  s17 <= s8(6);
  s11 <= s8(8 downto 7);
  s9 <= s8(10 downto 9);
  s18 <= s8(11);
  s19 <= s8(12);
  gate2: entity work.MUX_GATE_BUS_2
    generic map (
      Bits => 3)
    port map (
      sel => s9,
      in_0 => "000",
      in_1 => s0,
      in_2 => s1,
      in_3 => s2,
      p_out => s10);
  gate3: entity work.MUX_GATE_BUS_2
    generic map (
      Bits => 3)
    port map (
      sel => s11,
      in_0 => "000",
      in_1 => s0,
      in_2 => s1,
      in_3 => s2,
      p_out => s12);
  gate4: entity work.MUX_GATE_1
    port map (
      sel => s20,
      in_0 => '0',
      in_1 => s18,
      p_out => FL_EN);
  gate5: entity work.MUX_GATE_1
    port map (
      sel => s20,
      in_0 => '0',
      in_1 => s17,
      p_out => STR);
  gate6: entity work.MUX_GATE_1
    port map (
      sel => s20,
      in_0 => '0',
      in_1 => s16,
      p_out => WE);
  gate7: entity work.MUX_GATE_1
    port map (
      sel => s20,
      in_0 => '0',
      in_1 => s15,
      p_out => LDR);
  gate8: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 2)
    port map (
      sel => s20,
      in_0 => "00",
      in_1 => s14,
      p_out => DMUX);
  gate9: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 2)
    port map (
      sel => s20,
      in_0 => "00",
      in_1 => s13,
      p_out => ALUOP);
  gate10: entity work.MUX_GATE_1
    port map (
      sel => s20,
      in_0 => '0',
      in_1 => s19,
      p_out => HE);
  gate11: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 3)
    port map (
      sel => s20,
      in_0 => "000",
      in_1 => s10,
      p_out => RS1);
  gate12: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 3)
    port map (
      sel => s20,
      in_0 => "000",
      in_1 => s12,
      p_out => RS2);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;
entity COMP_GATE_SIGNED is
  generic ( Bits : integer );
  port (
    gr: out std_logic;
    eq: out std_logic;
    le: out std_logic;
    a: in std_logic_vector ((Bits-1) downto 0);
    b: in std_logic_vector ((Bits-1) downto 0) );
end COMP_GATE_SIGNED;

architecture Behavioral of COMP_GATE_SIGNED is
begin
  process(a, b)
  begin
    if (signed(a) > signed(b)) then
      le <= '0';
      eq <= '0';
      gr <= '1';
    elsif (signed(a) < signed(b)) then
      le <= '1';
      eq <= '0';
      gr <= '0';
    else
      le <= '0';
      eq <= '1';
      gr <= '0';
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity ripple_carry_adder_overflow is
  port (
    A: in std_logic_vector(15 downto 0);
    B: in std_logic_vector(15 downto 0);
    C_in: in std_logic;
    Q: out std_logic_vector(15 downto 0);
    C_out: out std_logic;
    V: out std_logic);
end ripple_carry_adder_overflow;

architecture Behavioral of ripple_carry_adder_overflow is
  signal s0: std_logic_vector(14 downto 0);
  signal s1: std_logic_vector(14 downto 0);
  signal s2: std_logic_vector(14 downto 0);
  signal s3: std_logic;
  signal s4: std_logic;
  signal s5: std_logic;
  signal s6: std_logic;
  signal C_out_temp: std_logic;
begin
  s0 <= A(14 downto 0);
  s4 <= A(15);
  s1 <= B(14 downto 0);
  s5 <= B(15);
  gate0: entity work.DIG_Add
    generic map (
      Bits => 15)
    port map (
      a => s0,
      b => s1,
      c_i => C_in,
      s => s2,
      c_o => s3);
  gate1: entity work.DIG_Add
    generic map (
      Bits => 1)
    port map (
      a => s4,
      b => s5,
      c_i => s3,
      s => s6,
      c_o => C_out_temp);
  Q(14 downto 0) <= s2;
  Q(15) <= s6;
  V <= (C_out_temp XOR s3);
  C_out <= C_out_temp;
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity alu is
  port (
    A: in std_logic_vector(15 downto 0); -- First input to ALU
    B: in std_logic_vector(15 downto 0); -- Second input to ALU
    ALUOP: in std_logic_vector(1 downto 0); -- Operation selection input
    RESULT: out std_logic_vector(15 downto 0); -- The result of this ALU operation
    FLAG: out std_logic_vector(3 downto 0) -- The flags associated with the result of this ALU operation
                                           -- 
                                           -- 0. Z (zero)
                                           -- 1. N (negative)
                                           -- 2. C (carry)
                                           -- 3. V (overflow)
    );
end alu;

architecture Behavioral of alu is
  signal RESULT_temp: std_logic_vector(15 downto 0);
  signal s0: std_logic_vector(15 downto 0);
  signal s1: std_logic;
  signal s2: std_logic_vector(15 downto 0);
  signal s3: std_logic_vector(15 downto 0);
  signal s4: std_logic_vector(15 downto 0);
  signal s5: std_logic_vector(15 downto 0);
  signal s6: std_logic;
  signal s7: std_logic;
  signal s8: std_logic;
  signal s9: std_logic;
  signal s10: std_logic;
  signal C_out: std_logic;
  signal V: std_logic;
begin
  s0 <= NOT B;
  gate0: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 2)
    port map (
      a => "01",
      b => ALUOP,
      eq => s1);
  s10 <= ALUOP(1);
  gate1: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => s1,
      in_0 => B,
      in_1 => s0,
      p_out => s2);
  s3 <= (A OR s2);
  s5 <= (A AND s2);
  gate2: entity work.ripple_carry_adder_overflow
    port map (
      A => A,
      B => s2,
      C_in => s1,
      Q => s4,
      C_out => C_out,
      V => V);
  gate3: entity work.MUX_GATE_BUS_2
    generic map (
      Bits => 16)
    port map (
      sel => ALUOP,
      in_0 => s4,
      in_1 => s4,
      in_2 => s5,
      in_3 => s3,
      p_out => RESULT_temp);
  gate4: entity work.MUX_GATE_1
    port map (
      sel => s10,
      in_0 => C_out,
      in_1 => '0',
      p_out => s8);
  gate5: entity work.MUX_GATE_1
    port map (
      sel => s10,
      in_0 => V,
      in_1 => '0',
      p_out => s9);
  gate6: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => RESULT_temp,
      b => "0000000000000000",
      eq => s6,
      le => s7);
  FLAG(0) <= s6;
  FLAG(1) <= s7;
  FLAG(2) <= s8;
  FLAG(3) <= s9;
  RESULT <= RESULT_temp;
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity main is
  port (
    CLK: in std_logic);
end main;

architecture Behavioral of main is
  signal STR: std_logic;
  signal LDR: std_logic;
  signal s0: std_logic_vector(15 downto 0);
  signal s1: std_logic_vector(15 downto 0);
  signal s2: std_logic_vector(15 downto 0);
  signal s3: std_logic_vector(15 downto 0);
  signal s4: std_logic_vector(15 downto 0);
  signal s5: std_logic_vector(15 downto 0);
  signal s6: std_logic_vector(15 downto 0);
  signal RS1: std_logic_vector(2 downto 0);
  signal RS2: std_logic_vector(2 downto 0);
  signal WS: std_logic_vector(2 downto 0);
  signal WE: std_logic;
  signal s7: std_logic_vector(15 downto 0);
  signal s8: std_logic_vector(15 downto 0);
  signal FL_EN: std_logic;
  signal HE: std_logic;
  signal s9: std_logic_vector(15 downto 0);
  signal s10: std_logic;
  signal s11: std_logic_vector(15 downto 0);
  signal DMUX: std_logic_vector(1 downto 0);
  signal s12: std_logic_vector(15 downto 0);
  signal s13: std_logic_vector(15 downto 0);
  signal s14: std_logic;
  signal ALUOP: std_logic_vector(1 downto 0);
  signal s15: std_logic_vector(3 downto 0);
begin
  gate0: entity work.DIG_RAMDualAccess -- RAM
    generic map (
      Bits => 16,
      AddrBits => 16)
    port map (
      str => STR,
      C => CLK,
      ld => LDR,
      n1A => s0,
      n1Din => s1,
      n2A => s2,
      n1D => s3,
      n2D => s4);
  gate1: entity work.DIG_Register_BUS -- PC
    generic map (
      Bits => 16)
    port map (
      D => s5,
      C => CLK,
      en => '1',
      Q => s2);
  gate2: entity work.DIG_Add -- +1
    generic map (
      Bits => 16)
    port map (
      a => "0000000000000001",
      b => s2,
      c_i => '0',
      s => s6);
  gate3: entity work.reg_file
    port map (
      RS1 => RS1,
      RS2 => RS2,
      WS => WS,
      WE => WE,
      p_IN => s7,
      clk => CLK,
      FL_IN => s8,
      FL_EN => FL_EN,
      PC_IN => s2,
      HE => HE,
      OUT1 => s0,
      OUT2 => s1,
      PC_S => s9,
      PC_WE => s10,
      FL_OUT => s11);
  gate4: entity work.MUX_GATE_BUS_2
    generic map (
      Bits => 16)
    port map (
      sel => DMUX,
      in_0 => s12,
      in_1 => s3,
      in_2 => s13,
      in_3 => "0000000000000000",
      p_out => s7);
  gate5: entity work.control_unit
    port map (
      INST => s4,
      FL_Z => s14,
      ALUOP => ALUOP,
      RS1 => RS1,
      RS2 => RS2,
      WS => WS,
      STR => STR,
      WE => WE,
      DMUX => DMUX,
      LDR => LDR,
      FL_EN => FL_EN,
      HE => HE);
  gate6: entity work.alu
    port map (
      A => s0,
      B => s1,
      ALUOP => ALUOP,
      RESULT => s12,
      FLAG => s15);
  s13(7 downto 0) <= s4(7 downto 0);
  s13(15 downto 8) <= "00000000";
  s8(3 downto 0) <= s15;
  s8(15 downto 4) <= "000000000000";
  gate7: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => s10,
      in_0 => s6,
      in_1 => s9,
      p_out => s5);
  s14 <= s11(0);
end Behavioral;

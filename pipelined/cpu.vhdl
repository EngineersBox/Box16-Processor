-- generated by Digital. Don't modify this file!
-- Any changes will be lost if this file is regenerated.

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity DIG_RAMDualAccess is
  generic (
    Bits : integer;       
    AddrBits : integer ); 
  port (
    n1D: out std_logic_vector ((Bits-1) downto 0);
    n2D: out std_logic_vector ((Bits-1) downto 0);
    str: in std_logic;
    C: in std_logic;
    ld: in std_logic;
    n1A: in std_logic_vector ((AddrBits-1) downto 0);
    n1Din: in std_logic_vector ((Bits-1) downto 0);
    n2A: in std_logic_vector ((AddrBits-1) downto 0) );
end DIG_RAMDualAccess;

architecture Behavioral of DIG_RAMDualAccess is
    -- CAUTION: uses distributed RAM
    type memoryType is array(0 to (2**AddrBits)-1) of STD_LOGIC_VECTOR((Bits-1) downto 0);
    signal memory : memoryType;
begin
  process ( C )
  begin
    if rising_edge(C) AND (str='1') then
      memory(to_integer(unsigned(n1A))) <= n1Din;
    end if;
  end process;
  n1D <= memory(to_integer(unsigned(n1A))) when ld='1' else (others => 'Z');
  n2D <= memory(to_integer(unsigned(n2A)));
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_Register_BUS is
  generic ( Bits: integer ); 
  port (
    Q: out std_logic_vector ((Bits-1) downto 0);
    D: in std_logic_vector ((Bits-1) downto 0);
    C: in std_logic;
    en: in std_logic );
end DIG_Register_BUS;

architecture Behavioral of DIG_Register_BUS is
  signal state : std_logic_vector ((Bits-1) downto 0) := (others => '0');
begin
   Q <= state;

   process ( C )
   begin
      if rising_edge(C) and (en='1') then
        state <= D;
      end if;
   end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;

entity DIG_Add is
  generic ( Bits: integer ); 
  port (
    s: out std_logic_vector((Bits-1) downto 0);
    c_o: out std_logic;
    a: in std_logic_vector((Bits-1) downto 0);
    b: in std_logic_vector((Bits-1) downto 0);
    c_i: in std_logic );
end DIG_Add;

architecture Behavioral of DIG_Add is
   signal temp : std_logic_vector(Bits downto 0);
begin
   temp <= ('0' & a) + b + c_i;

   s    <= temp((Bits-1) downto 0);
   c_o  <= temp(Bits);
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DEMUX_GATE_3 is
  port (
    out_0: out std_logic;
    out_1: out std_logic;
    out_2: out std_logic;
    out_3: out std_logic;
    out_4: out std_logic;
    out_5: out std_logic;
    out_6: out std_logic;
    out_7: out std_logic;
    sel: in std_logic_vector (2 downto 0);
    p_in: in std_logic );
end DEMUX_GATE_3;

architecture Behavioral of DEMUX_GATE_3 is
begin
    out_0 <= p_in when sel = "000" else '0';
    out_1 <= p_in when sel = "001" else '0';
    out_2 <= p_in when sel = "010" else '0';
    out_3 <= p_in when sel = "011" else '0';
    out_4 <= p_in when sel = "100" else '0';
    out_5 <= p_in when sel = "101" else '0';
    out_6 <= p_in when sel = "110" else '0';
    out_7 <= p_in when sel = "111" else '0';
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_1 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic;
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_1;

architecture Behavioral of MUX_GATE_BUS_1 is
begin
  with sel select
    p_out <=
      in_0 when '0',
      in_1 when '1',
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_3 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic_vector (2 downto 0);
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0);
    in_2: in std_logic_vector ((Bits-1) downto 0);
    in_3: in std_logic_vector ((Bits-1) downto 0);
    in_4: in std_logic_vector ((Bits-1) downto 0);
    in_5: in std_logic_vector ((Bits-1) downto 0);
    in_6: in std_logic_vector ((Bits-1) downto 0);
    in_7: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_3;

architecture Behavioral of MUX_GATE_BUS_3 is
begin
  with sel select
    p_out <=
      in_0 when "000",
      in_1 when "001",
      in_2 when "010",
      in_3 when "011",
      in_4 when "100",
      in_5 when "101",
      in_6 when "110",
      in_7 when "111",
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity high_mask_in is
  port (
    D_HIGH: in std_logic_vector(15 downto 0);
    D: in std_logic_vector(15 downto 0);
    EN: in std_logic;
    Q: out std_logic_vector(15 downto 0));
end high_mask_in;

architecture Behavioral of high_mask_in is
  signal s0: std_logic_vector(15 downto 0);
begin
  s0(7 downto 0) <= D(7 downto 0);
  s0(15 downto 8) <= D_HIGH(7 downto 0);
  gate0: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => EN,
      in_0 => D_HIGH,
      in_1 => s0,
      p_out => Q);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity reg_file is
  port (
    RS1: in std_logic_vector(2 downto 0); -- The index of the register which should output its value to OUT1.
    RS2: in std_logic_vector(2 downto 0); -- The index of the register which should output its value to OUT2.
    WS: in std_logic_vector(2 downto 0); -- The index of the register which should save the value on IN on the next clock cycle (if WE is high).
    WE: in std_logic; -- Whether the register selected by WS should save the value from IN on the next cycle.
    p_IN: in std_logic_vector(15 downto 0); -- The value to be saved into the register specified by WS if WE is high,
    CLK: in std_logic;
    FL_IN: in std_logic_vector(15 downto 0); -- The value to be saved into the register specified by WS if WE is high,
    FL_EN: in std_logic; -- Whether the register selected by WS should save the value from IN on the next cycle.
    PC_IN: in std_logic_vector(15 downto 0);
    HE: in std_logic;
    OUT1: out std_logic_vector(15 downto 0); -- The value in the register specified by RS1.
    OUT2: out std_logic_vector(15 downto 0) -- The value in the register specified by RS2.
    );
end reg_file;

architecture Behavioral of reg_file is
  signal s0: std_logic_vector(15 downto 0);
  signal s1: std_logic;
  signal s2: std_logic_vector(15 downto 0);
  signal s3: std_logic_vector(15 downto 0);
  signal s4: std_logic;
  signal s5: std_logic_vector(15 downto 0);
  signal s6: std_logic_vector(15 downto 0);
  signal s7: std_logic;
  signal s8: std_logic_vector(15 downto 0);
  signal s9: std_logic_vector(15 downto 0);
  signal s10: std_logic;
  signal s11: std_logic_vector(15 downto 0);
  signal s12: std_logic_vector(15 downto 0);
  signal s13: std_logic_vector(15 downto 0);
  signal s14: std_logic;
  signal s15: std_logic;
  signal s16: std_logic_vector(15 downto 0);
  signal s17: std_logic;
  signal s18: std_logic_vector(15 downto 0);
begin
  gate0: entity work.DEMUX_GATE_3
    port map (
      sel => WS,
      p_in => WE,
      out_1 => s1,
      out_2 => s4,
      out_3 => s7,
      out_4 => s10,
      out_5 => s14,
      out_7 => s15);
  s17 <= (s14 OR FL_EN);
  gate1: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => s15,
      in_0 => PC_IN,
      in_1 => p_IN,
      p_out => s18);
  gate2: entity work.DIG_Register_BUS -- R1
    generic map (
      Bits => 16)
    port map (
      D => s0,
      C => CLK,
      en => s1,
      Q => s2);
  gate3: entity work.DIG_Register_BUS -- R2
    generic map (
      Bits => 16)
    port map (
      D => s3,
      C => CLK,
      en => s4,
      Q => s5);
  gate4: entity work.DIG_Register_BUS -- R3
    generic map (
      Bits => 16)
    port map (
      D => s6,
      C => CLK,
      en => s7,
      Q => s8);
  gate5: entity work.DIG_Register_BUS -- R4
    generic map (
      Bits => 16)
    port map (
      D => s9,
      C => CLK,
      en => s10,
      Q => s11);
  gate6: entity work.MUX_GATE_BUS_3
    generic map (
      Bits => 16)
    port map (
      sel => RS1,
      in_0 => "0000000000000000",
      in_1 => s2,
      in_2 => s5,
      in_3 => s8,
      in_4 => s11,
      in_5 => s12,
      in_6 => "0000000000000000",
      in_7 => s13,
      p_out => OUT1);
  gate7: entity work.MUX_GATE_BUS_3
    generic map (
      Bits => 16)
    port map (
      sel => RS2,
      in_0 => "0000000000000000",
      in_1 => s2,
      in_2 => s5,
      in_3 => s8,
      in_4 => s11,
      in_5 => s12,
      in_6 => "0000000000000000",
      in_7 => s13,
      p_out => OUT2);
  gate8: entity work.DIG_Register_BUS -- FL
    generic map (
      Bits => 16)
    port map (
      D => s16,
      C => CLK,
      en => s17,
      Q => s12);
  gate9: entity work.high_mask_in
    port map (
      D_HIGH => p_IN,
      D => s2,
      EN => HE,
      Q => s0);
  gate10: entity work.high_mask_in
    port map (
      D_HIGH => p_IN,
      D => s5,
      EN => HE,
      Q => s3);
  gate11: entity work.high_mask_in
    port map (
      D_HIGH => p_IN,
      D => s8,
      EN => HE,
      Q => s6);
  gate12: entity work.high_mask_in
    port map (
      D_HIGH => p_IN,
      D => s11,
      EN => HE,
      Q => s9);
  gate13: entity work.high_mask_in
    port map (
      D_HIGH => FL_IN,
      D => s12,
      EN => HE,
      Q => s16);
  gate14: entity work.high_mask_in
    port map (
      D_HIGH => s18,
      D => s13,
      EN => HE,
      Q => s13);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity COMP_GATE_UNSIGNED is
  generic ( Bits : integer );
  port (
    gr: out std_logic;
    eq: out std_logic;
    le: out std_logic;
    a: in std_logic_vector ((Bits-1) downto 0);
    b: in std_logic_vector ((Bits-1) downto 0) );
end COMP_GATE_UNSIGNED;

architecture Behavioral of COMP_GATE_UNSIGNED is
begin
  process(a, b)
  begin
    if (a > b ) then
      le <= '0';
      eq <= '0';
      gr <= '1';
    elsif (a < b) then
      le <= '1';
      eq <= '0';
      gr <= '0';
    else
      le <= '0';
      eq <= '1';
      gr <= '0';
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.std_logic_unsigned.all;
use IEEE.NUMERIC_STD.ALL;

entity DIG_LUT_OpcodeCL is
  port (
    n0: in std_logic;
    n1: in std_logic;
    n2: in std_logic;
    n3: in std_logic;

    p_out: out std_logic_vector (11 downto 0)
);
end DIG_LUT_OpcodeCL;

architecture Behavioral of DIG_LUT_OpcodeCL is
  type mem is array ( 0 to 15) of std_logic_vector (11 downto 0);
  constant my_lut : mem := (
    "010000010000", "010000010100", "000000000000", "000000000000", 
    "000100000000", "011000000001", "000000000000", "000000000000", 
    "010000001010", "010001001010", "010010001010", "010011001010", 
    "000000000000", "000000000000", "000000000000", "000000000000"
    );
  signal temp : std_logic_vector(3 downto 0);
begin
  temp <= n3 & n2 & n1 & n0;
  p_out <= my_lut(to_integer(unsigned(temp)));
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_1 is
  port (
    p_out: out std_logic;
    sel: in std_logic;
    
    in_0: in std_logic;
    in_1: in std_logic );
end MUX_GATE_1;

architecture Behavioral of MUX_GATE_1 is
begin
  with sel select
    p_out <=
      in_0 when '0',
      in_1 when '1',
      '0' when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity control_unit is
  port (
    INST: in std_logic_vector(15 downto 0);
    FlagWriteD: out std_logic;
    ALUSrcD: out std_logic;
    BranchD: out std_logic;
    ALUCtrlD: out std_logic_vector(1 downto 0);
    MemWriteD: out std_logic;
    MemToRegD: out std_logic;
    RegWriteD: out std_logic;
    PCSrcD: out std_logic;
    SethD: out std_logic;
    FlagEN: out std_logic;
    LDR: out std_logic;
    InsertNOP: out std_logic);
end control_unit;

architecture Behavioral of control_unit is
  signal s0: std_logic_vector(2 downto 0);
  signal s1: std_logic_vector(3 downto 0);
  signal s2: std_logic;
  signal s3: std_logic;
  signal s4: std_logic;
  signal s5: std_logic;
  signal s6: std_logic_vector(11 downto 0);
  signal s7: std_logic;
  signal s8: std_logic;
  signal s9: std_logic;
  signal s10: std_logic_vector(1 downto 0);
  signal s11: std_logic;
  signal s12: std_logic;
  signal s13: std_logic;
  signal s14: std_logic;
  signal s15: std_logic;
  signal s16: std_logic;
  signal InsertNOP_temp: std_logic;
  signal s17: std_logic;
  signal s18: std_logic_vector(1 downto 0);
  signal s19: std_logic;
begin
  s18(0) <= '0';
  s18(1) <= '0';
  gate0: entity work.COMP_GATE_UNSIGNED
    generic map (
      Bits => 16)
    port map (
      a => "0000000000000000",
      b => INST,
      eq => InsertNOP_temp);
  s0 <= INST(10 downto 8);
  s1 <= INST(15 downto 12);
  gate1: entity work.COMP_GATE_UNSIGNED -- Is Rd PC
    generic map (
      Bits => 3)
    port map (
      a => s0,
      b => "111",
      eq => s16);
  s2 <= s1(0);
  s3 <= s1(1);
  s4 <= s1(2);
  s5 <= s1(3);
  gate2: entity work.DIG_LUT_OpcodeCL -- OpcodeCL
    port map (
      n0 => s2,
      n1 => s3,
      n2 => s4,
      n3 => s5,
      p_out => s6);
  s17 <= (s16 OR s6(11));
  s19 <= (s16 OR s6(5));
  s7 <= s6(10);
  s8 <= s6(9);
  s9 <= s6(8);
  s10 <= s6(7 downto 6);
  s11 <= s6(4);
  s12 <= s6(3);
  s13 <= s6(2);
  s14 <= s6(1);
  s15 <= s6(0);
  gate3: entity work.MUX_GATE_1
    port map (
      sel => InsertNOP_temp,
      in_0 => s17,
      in_1 => '0',
      p_out => PCSrcD);
  gate4: entity work.MUX_GATE_1
    port map (
      sel => InsertNOP_temp,
      in_0 => s7,
      in_1 => '0',
      p_out => RegWriteD);
  gate5: entity work.MUX_GATE_1
    port map (
      sel => InsertNOP_temp,
      in_0 => s8,
      in_1 => '0',
      p_out => MemToRegD);
  gate6: entity work.MUX_GATE_1
    port map (
      sel => InsertNOP_temp,
      in_0 => s9,
      in_1 => '0',
      p_out => MemWriteD);
  gate7: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 2)
    port map (
      sel => InsertNOP_temp,
      in_0 => s10,
      in_1 => s18,
      p_out => ALUCtrlD);
  gate8: entity work.MUX_GATE_1
    port map (
      sel => InsertNOP_temp,
      in_0 => s19,
      in_1 => '0',
      p_out => BranchD);
  gate9: entity work.MUX_GATE_1
    port map (
      sel => InsertNOP_temp,
      in_0 => s11,
      in_1 => '0',
      p_out => ALUSrcD);
  gate10: entity work.MUX_GATE_1
    port map (
      sel => InsertNOP_temp,
      in_0 => s12,
      in_1 => '0',
      p_out => FlagWriteD);
  gate11: entity work.MUX_GATE_1
    port map (
      sel => InsertNOP_temp,
      in_0 => s13,
      in_1 => '0',
      p_out => SethD);
  gate12: entity work.MUX_GATE_1
    port map (
      sel => InsertNOP_temp,
      in_0 => s14,
      in_1 => '0',
      p_out => FlagEN);
  gate13: entity work.MUX_GATE_1
    port map (
      sel => InsertNOP_temp,
      in_0 => s15,
      in_1 => '0',
      p_out => LDR);
  InsertNOP <= InsertNOP_temp;
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity if_id_ppr is
  port (
    INSN_IN: in std_logic_vector(15 downto 0);
    CLK: in std_logic;
    EN: in std_logic;
    CLR: in std_logic;
    INSN_OUT: out std_logic_vector(15 downto 0));
end if_id_ppr;

architecture Behavioral of if_id_ppr is
  signal s0: std_logic_vector(15 downto 0);
begin
  gate0: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => CLR,
      in_0 => INSN_IN,
      in_1 => "0000000000000000",
      p_out => s0);
  gate1: entity work.DIG_Register_BUS -- INSN
    generic map (
      Bits => 16)
    port map (
      D => s0,
      C => CLK,
      en => EN,
      Q => INSN_OUT);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity DIG_Register is
  
  port (
    Q: out std_logic;
    D: in std_logic;
    C: in std_logic;
    en: in std_logic );
end DIG_Register;

architecture Behavioral of DIG_Register is
  signal state : std_logic := '0';
begin
   Q <= state;

   process ( C )
   begin
      if rising_edge(C) and (en='1') then
        state <= D;
      end if;
   end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity id_ex_ppr is
  port (
    CondD: in std_logic;
    Ra1D: in std_logic_vector(15 downto 0);
    Ra2D: in std_logic_vector(15 downto 0);
    SEI16D: in std_logic_vector(15 downto 0);
    CLK: in std_logic;
    WAD: in std_logic_vector(2 downto 0);
    FlagsD: in std_logic_vector(3 downto 0);
    PCSrcD: in std_logic;
    RegWriteD: in std_logic;
    MemToRegD: in std_logic;
    ALUCtrlD: in std_logic_vector(1 downto 0);
    BranchD: in std_logic;
    ALUSrcD: in std_logic;
    FlagWriteD: in std_logic;
    MemWriteD: in std_logic;
    LDRD: in std_logic;
    SethD: in std_logic;
    Rd1D: in std_logic_vector(15 downto 0);
    Rd2D: in std_logic_vector(15 downto 0);
    CLR: in std_logic;
    CondE: out std_logic;
    Ra1E: out std_logic_vector(15 downto 0);
    Ra2E: out std_logic_vector(15 downto 0);
    SEI16E: out std_logic_vector(15 downto 0);
    WAE: out std_logic_vector(2 downto 0);
    FlagsE: out std_logic_vector(3 downto 0);
    PCSrcE: out std_logic;
    RegWriteE: out std_logic;
    MemToRegE: out std_logic;
    ALUCtrlE: out std_logic_vector(1 downto 0);
    BranchE: out std_logic;
    ALUSrcE: out std_logic;
    FlagWriteE: out std_logic;
    MemWriteE: out std_logic;
    LDRE: out std_logic;
    SethE: out std_logic;
    Rd1E: out std_logic_vector(15 downto 0);
    Rd2E: out std_logic_vector(15 downto 0));
end id_ex_ppr;

architecture Behavioral of id_ex_ppr is
  signal s0: std_logic_vector(15 downto 0);
  signal s1: std_logic_vector(15 downto 0);
  signal s2: std_logic_vector(15 downto 0);
  signal s3: std_logic_vector(2 downto 0);
  signal s4: std_logic_vector(15 downto 0);
  signal s5: std_logic_vector(15 downto 0);
begin
  gate0: entity work.DIG_Register -- Cond
    port map (
      D => CondD,
      C => CLK,
      en => '1',
      Q => CondE);
  gate1: entity work.DIG_Register_BUS -- Flags
    generic map (
      Bits => 4)
    port map (
      D => FlagsD,
      C => CLK,
      en => '1',
      Q => FlagsE);
  gate2: entity work.DIG_Register -- PCSrc
    port map (
      D => PCSrcD,
      C => CLK,
      en => '1',
      Q => PCSrcE);
  gate3: entity work.DIG_Register -- RegWrite
    port map (
      D => RegWriteD,
      C => CLK,
      en => '1',
      Q => RegWriteE);
  gate4: entity work.DIG_Register -- MemToReg
    port map (
      D => MemToRegD,
      C => CLK,
      en => '1',
      Q => MemToRegE);
  gate5: entity work.DIG_Register_BUS -- ALUCtrl
    generic map (
      Bits => 2)
    port map (
      D => ALUCtrlD,
      C => CLK,
      en => '1',
      Q => ALUCtrlE);
  gate6: entity work.DIG_Register -- BranchD
    port map (
      D => BranchD,
      C => CLK,
      en => '1',
      Q => BranchE);
  gate7: entity work.DIG_Register -- ALUSrc
    port map (
      D => ALUSrcD,
      C => CLK,
      en => '1',
      Q => ALUSrcE);
  gate8: entity work.DIG_Register -- FlagWrite
    port map (
      D => FlagWriteD,
      C => CLK,
      en => '1',
      Q => FlagWriteE);
  gate9: entity work.DIG_Register -- MemWrite
    port map (
      D => MemWriteD,
      C => CLK,
      en => '1',
      Q => MemWriteE);
  gate10: entity work.DIG_Register -- LDR
    port map (
      D => LDRD,
      C => CLK,
      en => '1',
      Q => LDRE);
  gate11: entity work.DIG_Register -- SethD
    port map (
      D => SethD,
      C => CLK,
      en => '1',
      Q => SethE);
  gate12: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => CLR,
      in_0 => Rd2D,
      in_1 => "0000000000000000",
      p_out => s5);
  gate13: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => CLR,
      in_0 => Rd1D,
      in_1 => "0000000000000000",
      p_out => s4);
  gate14: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => CLR,
      in_0 => Ra2D,
      in_1 => "0000000000000000",
      p_out => s1);
  gate15: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => CLR,
      in_0 => Ra1D,
      in_1 => "0000000000000000",
      p_out => s0);
  gate16: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => CLR,
      in_0 => SEI16D,
      in_1 => "0000000000000000",
      p_out => s2);
  gate17: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 3)
    port map (
      sel => CLR,
      in_0 => WAD,
      in_1 => "000",
      p_out => s3);
  gate18: entity work.DIG_Register_BUS -- Ra1
    generic map (
      Bits => 16)
    port map (
      D => s0,
      C => CLK,
      en => '1',
      Q => Ra1E);
  gate19: entity work.DIG_Register_BUS -- Ra2
    generic map (
      Bits => 16)
    port map (
      D => s1,
      C => CLK,
      en => '1',
      Q => Ra2E);
  gate20: entity work.DIG_Register_BUS -- SEI16
    generic map (
      Bits => 16)
    port map (
      D => s2,
      C => CLK,
      en => '1',
      Q => SEI16E);
  gate21: entity work.DIG_Register_BUS -- WA
    generic map (
      Bits => 3)
    port map (
      D => s3,
      C => CLK,
      en => '1',
      Q => WAE);
  gate22: entity work.DIG_Register_BUS -- Rd1
    generic map (
      Bits => 16)
    port map (
      D => s4,
      C => CLK,
      en => '1',
      Q => Rd1E);
  gate23: entity work.DIG_Register_BUS -- Rd2
    generic map (
      Bits => 16)
    port map (
      D => s5,
      C => CLK,
      en => '1',
      Q => Rd2E);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity ex_mem_ppr is
  port (
    CLK: in std_logic;
    PCSrcE: in std_logic;
    RegWriteE: in std_logic;
    MemToRegE: in std_logic;
    MemWriteE: in std_logic;
    ALUResultE: in std_logic_vector(15 downto 0);
    WriteDataE: in std_logic_vector(15 downto 0);
    WAE: in std_logic_vector(2 downto 0);
    LDRE: in std_logic;
    sethE: in std_logic;
    PCSrcM: out std_logic;
    RegWriteM: out std_logic;
    MemToReg: out std_logic;
    MemWriteM: out std_logic;
    ALUResultM: out std_logic_vector(15 downto 0);
    WriteDataM: out std_logic_vector(15 downto 0);
    WA3M: out std_logic_vector(2 downto 0);
    LDRM: out std_logic;
    sethM: out std_logic);
end ex_mem_ppr;

architecture Behavioral of ex_mem_ppr is
begin
  gate0: entity work.DIG_Register -- PCSrc
    port map (
      D => PCSrcE,
      C => CLK,
      en => '1',
      Q => PCSrcM);
  gate1: entity work.DIG_Register -- RegWrite
    port map (
      D => RegWriteE,
      C => CLK,
      en => '1',
      Q => RegWriteM);
  gate2: entity work.DIG_Register -- MemToReg
    port map (
      D => MemToRegE,
      C => CLK,
      en => '1',
      Q => MemToReg);
  gate3: entity work.DIG_Register -- MemWrite
    port map (
      D => MemWriteE,
      C => CLK,
      en => '1',
      Q => MemWriteM);
  gate4: entity work.DIG_Register_BUS -- ALUResult
    generic map (
      Bits => 16)
    port map (
      D => ALUResultE,
      C => CLK,
      en => '1',
      Q => ALUResultM);
  gate5: entity work.DIG_Register_BUS -- WriteData
    generic map (
      Bits => 16)
    port map (
      D => WriteDataE,
      C => CLK,
      en => '1',
      Q => WriteDataM);
  gate6: entity work.DIG_Register_BUS -- WA
    generic map (
      Bits => 3)
    port map (
      D => WAE,
      C => CLK,
      en => '1',
      Q => WA3M);
  gate7: entity work.DIG_Register -- LDR
    port map (
      D => LDRE,
      C => CLK,
      en => '1',
      Q => LDRM);
  gate8: entity work.DIG_Register -- setHE
    port map (
      D => sethE,
      C => CLK,
      en => '1',
      Q => sethM);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity mem_wb_ppr is
  port (
    CLK: in std_logic;
    PCSrcM: in std_logic;
    RegWriteM: in std_logic;
    MemToRegM: in std_logic;
    ReadDataM: in std_logic_vector(15 downto 0);
    ALUResultM: in std_logic_vector(15 downto 0);
    WA3M: in std_logic_vector(2 downto 0);
    SethM: in std_logic;
    PCSrcW: out std_logic;
    RegWriteW: out std_logic;
    MemToRegW: out std_logic;
    ReadDataW: out std_logic_vector(15 downto 0);
    ALUResultW: out std_logic_vector(15 downto 0);
    WA3W: out std_logic_vector(2 downto 0);
    SethW: out std_logic);
end mem_wb_ppr;

architecture Behavioral of mem_wb_ppr is
begin
  gate0: entity work.DIG_Register -- PCSrc
    port map (
      D => PCSrcM,
      C => CLK,
      en => '1',
      Q => PCSrcW);
  gate1: entity work.DIG_Register -- RegWrite
    port map (
      D => RegWriteM,
      C => CLK,
      en => '1',
      Q => RegWriteW);
  gate2: entity work.DIG_Register -- MemToReg
    port map (
      D => MemToRegM,
      C => CLK,
      en => '1',
      Q => MemToRegW);
  gate3: entity work.DIG_Register_BUS -- ReadData
    generic map (
      Bits => 16)
    port map (
      D => ReadDataM,
      C => CLK,
      en => '1',
      Q => ReadDataW);
  gate4: entity work.DIG_Register_BUS -- ALUResult
    generic map (
      Bits => 16)
    port map (
      D => ALUResultM,
      C => CLK,
      en => '1',
      Q => ALUResultW);
  gate5: entity work.DIG_Register_BUS -- WA3
    generic map (
      Bits => 3)
    port map (
      D => WA3M,
      C => CLK,
      en => '1',
      Q => WA3W);
  gate6: entity work.DIG_Register -- Seth
    port map (
      D => SethM,
      C => CLK,
      en => '1',
      Q => SethW);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;



entity DIG_BitExtender is
  generic ( inputBits  : integer;  
            outputBits : integer); 
  port (
    p_in: in std_logic_vector ((inputBits-1) downto 0);
    p_out: out std_logic_vector ((outputBits-1) downto 0) );
end DIG_BitExtender;

architecture DIG_BitExtender_arch of DIG_BitExtender is
begin
    p_out((inputBits-2) downto 0) <= p_in((inputBits-2) downto 0);
    p_out((outputBits-1) downto (inputBits-1)) <= (others => p_in(inputBits-1));
end DIG_BitExtender_arch;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity condition_unit is
  port (
    FlagWriteE: in std_logic;
    CondE: in std_logic;
    FlagsE: in std_logic_vector(3 downto 0);
    ALUFlags: in std_logic_vector(3 downto 0);
    CondExE: out std_logic;
    FlagsM: out std_logic_vector(3 downto 0));
end condition_unit;

architecture Behavioral of condition_unit is
begin
  gate0: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 4)
    port map (
      sel => FlagWriteE,
      in_0 => FlagsE,
      in_1 => ALUFlags,
      p_out => FlagsM);
  CondExE <= (FlagsE(0) OR NOT CondE);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;
entity COMP_GATE_SIGNED is
  generic ( Bits : integer );
  port (
    gr: out std_logic;
    eq: out std_logic;
    le: out std_logic;
    a: in std_logic_vector ((Bits-1) downto 0);
    b: in std_logic_vector ((Bits-1) downto 0) );
end COMP_GATE_SIGNED;

architecture Behavioral of COMP_GATE_SIGNED is
begin
  process(a, b)
  begin
    if (signed(a) > signed(b)) then
      le <= '0';
      eq <= '0';
      gr <= '1';
    elsif (signed(a) < signed(b)) then
      le <= '1';
      eq <= '0';
      gr <= '0';
    else
      le <= '0';
      eq <= '1';
      gr <= '0';
    end if;
  end process;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity ripple_carry_adder_overflow is
  port (
    A: in std_logic_vector(15 downto 0);
    B: in std_logic_vector(15 downto 0);
    C_in: in std_logic;
    Q: out std_logic_vector(15 downto 0);
    C_out: out std_logic;
    V: out std_logic);
end ripple_carry_adder_overflow;

architecture Behavioral of ripple_carry_adder_overflow is
  signal s0: std_logic_vector(14 downto 0);
  signal s1: std_logic_vector(14 downto 0);
  signal s2: std_logic_vector(14 downto 0);
  signal s3: std_logic;
  signal s4: std_logic;
  signal s5: std_logic;
  signal s6: std_logic;
  signal C_out_temp: std_logic;
begin
  s0 <= A(14 downto 0);
  s4 <= A(15);
  s1 <= B(14 downto 0);
  s5 <= B(15);
  gate0: entity work.DIG_Add
    generic map (
      Bits => 15)
    port map (
      a => s0,
      b => s1,
      c_i => C_in,
      s => s2,
      c_o => s3);
  gate1: entity work.DIG_Add
    generic map (
      Bits => 1)
    port map (
      a => s4,
      b => s5,
      c_i => s3,
      s => s6,
      c_o => C_out_temp);
  Q(14 downto 0) <= s2;
  Q(15) <= s6;
  V <= (C_out_temp XOR s3);
  C_out <= C_out_temp;
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;

entity MUX_GATE_BUS_2 is
  generic ( Bits : integer ); 
  port (
    p_out: out std_logic_vector ((Bits-1) downto 0);
    sel: in std_logic_vector (1 downto 0);
    
    in_0: in std_logic_vector ((Bits-1) downto 0);
    in_1: in std_logic_vector ((Bits-1) downto 0);
    in_2: in std_logic_vector ((Bits-1) downto 0);
    in_3: in std_logic_vector ((Bits-1) downto 0) );
end MUX_GATE_BUS_2;

architecture Behavioral of MUX_GATE_BUS_2 is
begin
  with sel select
    p_out <=
      in_0 when "00",
      in_1 when "01",
      in_2 when "10",
      in_3 when "11",
      (others => '0') when others;
end Behavioral;


LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity alu is
  port (
    A: in std_logic_vector(15 downto 0); -- First input to ALU
    B: in std_logic_vector(15 downto 0); -- Second input to ALU
    ALUOP: in std_logic_vector(1 downto 0); -- Operation selection input
    RESULT: out std_logic_vector(15 downto 0); -- The result of this ALU operation
    FLAG: out std_logic_vector(3 downto 0) -- The flags associated with the result of this ALU operation
                                           -- 
                                           -- 0. Z (zero)
                                           -- 1. N (negative)
                                           -- 2. C (carry)
                                           -- 3. V (overflow)
    );
end alu;

architecture Behavioral of alu is
  signal RESULT_temp: std_logic_vector(15 downto 0);
  signal s0: std_logic_vector(15 downto 0);
  signal s1: std_logic;
  signal s2: std_logic_vector(15 downto 0);
  signal s3: std_logic_vector(15 downto 0);
  signal s4: std_logic_vector(15 downto 0);
  signal s5: std_logic_vector(15 downto 0);
  signal s6: std_logic;
  signal s7: std_logic;
  signal s8: std_logic;
  signal s9: std_logic;
  signal s10: std_logic;
  signal C_out: std_logic;
  signal V: std_logic;
begin
  s0 <= NOT B;
  gate0: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 2)
    port map (
      a => "01",
      b => ALUOP,
      eq => s1);
  s10 <= ALUOP(1);
  gate1: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => s1,
      in_0 => B,
      in_1 => s0,
      p_out => s2);
  s3 <= (A OR s2);
  s5 <= (A AND s2);
  gate2: entity work.ripple_carry_adder_overflow
    port map (
      A => A,
      B => s2,
      C_in => s1,
      Q => s4,
      C_out => C_out,
      V => V);
  gate3: entity work.MUX_GATE_BUS_2
    generic map (
      Bits => 16)
    port map (
      sel => ALUOP,
      in_0 => s4,
      in_1 => s4,
      in_2 => s5,
      in_3 => s3,
      p_out => RESULT_temp);
  gate4: entity work.MUX_GATE_1
    port map (
      sel => s10,
      in_0 => C_out,
      in_1 => '0',
      p_out => s8);
  gate5: entity work.MUX_GATE_1
    port map (
      sel => s10,
      in_0 => V,
      in_1 => '0',
      p_out => s9);
  gate6: entity work.COMP_GATE_SIGNED
    generic map (
      Bits => 16)
    port map (
      a => RESULT_temp,
      b => "0000000000000000",
      eq => s6,
      le => s7);
  FLAG(0) <= s6;
  FLAG(1) <= s7;
  FLAG(2) <= s8;
  FLAG(3) <= s9;
  RESULT <= RESULT_temp;
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity data_hazard_forwarding is
  port (
    I_3: in std_logic;
    I_2: in std_logic;
    I_1: in std_logic;
    I_0: in std_logic;
    ForwardE: out std_logic_vector(1 downto 0));
end data_hazard_forwarding;

architecture Behavioral of data_hazard_forwarding is
begin
  ForwardE(0) <= ((I_3 AND NOT I_1 AND I_0) OR (I_3 AND NOT I_2 AND I_0));
  ForwardE(1) <= (I_2 AND I_1);
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity hazard_unit is
  port (
    RA1D: in std_logic_vector(15 downto 0);
    RA2D: in std_logic_vector(15 downto 0);
    WA3E: in std_logic_vector(15 downto 0);
    MemtoRegE: in std_logic;
    PCSrcD: in std_logic;
    PCSrcE: in std_logic;
    PCSrcM: in std_logic;
    PCSrcW: in std_logic;
    BranchTakenE: in std_logic;
    RegWriteM: in std_logic;
    RegWriteW: in std_logic;
    RA1E: in std_logic_vector(15 downto 0);
    RA2E: in std_logic_vector(15 downto 0);
    WA3M: in std_logic_vector(15 downto 0);
    WA3W: in std_logic_vector(15 downto 0);
    ALUSrcE: in std_logic;
    StallF: out std_logic;
    StallD: out std_logic;
    FlushD: out std_logic;
    FlushE: out std_logic;
    ForwardBE: out std_logic_vector(1 downto 0);
    ForwardAE: out std_logic_vector(1 downto 0));
end hazard_unit;

architecture Behavioral of hazard_unit is
  signal s0: std_logic;
  signal s1: std_logic;
  signal StallD_temp: std_logic;
  signal s2: std_logic;
  signal s3: std_logic;
  signal s4: std_logic;
  signal s5: std_logic;
  signal s6: std_logic;
  signal s7: std_logic_vector(1 downto 0);
  signal s8: std_logic_vector(1 downto 0);
  signal s9: std_logic;
  signal s10: std_logic;
  signal s11: std_logic;
  signal s12: std_logic;
begin
  gate0: entity work.COMP_GATE_UNSIGNED -- Match1D_E
    generic map (
      Bits => 16)
    port map (
      a => RA1D,
      b => WA3E,
      eq => s0);
  gate1: entity work.COMP_GATE_UNSIGNED -- Match2DE
    generic map (
      Bits => 16)
    port map (
      a => RA2D,
      b => WA3E,
      eq => s1);
  s2 <= (PCSrcM OR PCSrcE OR PCSrcD);
  gate2: entity work.COMP_GATE_UNSIGNED -- Match1_EM
    generic map (
      Bits => 16)
    port map (
      a => WA3M,
      b => RA1E,
      eq => s3);
  gate3: entity work.COMP_GATE_UNSIGNED -- Match1_EW
    generic map (
      Bits => 16)
    port map (
      a => WA3W,
      b => RA1E,
      eq => s4);
  gate4: entity work.COMP_GATE_UNSIGNED -- Match2_EM
    generic map (
      Bits => 16)
    port map (
      a => WA3M,
      b => RA2E,
      eq => s5);
  gate5: entity work.COMP_GATE_UNSIGNED -- Match2_EW
    generic map (
      Bits => 16)
    port map (
      a => WA3W,
      b => RA2E,
      eq => s6);
  gate6: entity work.COMP_GATE_UNSIGNED
    generic map (
      Bits => 16)
    port map (
      a => RA2E,
      b => "0000000000000000",
      le => s11);
  gate7: entity work.COMP_GATE_UNSIGNED
    generic map (
      Bits => 16)
    port map (
      a => RA1E,
      b => "0000000000000000",
      le => s12);
  StallD_temp <= ((s0 OR s1) AND MemtoRegE);
  FlushD <= (PCSrcW OR s2 OR BranchTakenE);
  gate8: entity work.data_hazard_forwarding
    port map (
      I_3 => s4,
      I_2 => s3,
      I_1 => RegWriteM,
      I_0 => RegWriteW,
      ForwardE => s7);
  gate9: entity work.data_hazard_forwarding
    port map (
      I_3 => s6,
      I_2 => s5,
      I_1 => RegWriteM,
      I_0 => RegWriteW,
      ForwardE => s8);
  s9 <= (s12 OR ALUSrcE);
  s10 <= (s11 OR ALUSrcE);
  StallF <= (s2 OR StallD_temp);
  FlushE <= (BranchTakenE OR StallD_temp);
  gate10: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 2)
    port map (
      sel => s9,
      in_0 => s7,
      in_1 => "00",
      p_out => ForwardAE);
  gate11: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 2)
    port map (
      sel => s10,
      in_0 => s8,
      in_1 => "00",
      p_out => ForwardBE);
  StallD <= StallD_temp;
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity reg_address_extender is
  port (
    p_IN: in std_logic_vector(2 downto 0);
    p_OUT: out std_logic_vector(15 downto 0));
end reg_address_extender;

architecture Behavioral of reg_address_extender is
begin
  p_OUT(2 downto 0) <= p_IN;
  p_OUT(15 downto 3) <= "0000000000000";
end Behavioral;

LIBRARY ieee;
USE ieee.std_logic_1164.all;
USE ieee.numeric_std.all;

entity main is
  port (
    CLK: in std_logic);
end main;

architecture Behavioral of main is
  signal s0: std_logic;
  signal s1: std_logic;
  signal s2: std_logic_vector(15 downto 0);
  signal s3: std_logic_vector(15 downto 0);
  signal s4: std_logic_vector(15 downto 0);
  signal s5: std_logic_vector(15 downto 0);
  signal s6: std_logic_vector(15 downto 0);
  signal s7: std_logic_vector(15 downto 0);
  signal s8: std_logic;
  signal s9: std_logic_vector(15 downto 0);
  signal s10: std_logic_vector(2 downto 0);
  signal s11: std_logic_vector(2 downto 0);
  signal s12: std_logic_vector(2 downto 0);
  signal s13: std_logic;
  signal s14: std_logic_vector(15 downto 0);
  signal s15: std_logic_vector(15 downto 0);
  signal s16: std_logic;
  signal s17: std_logic;
  signal s18: std_logic_vector(15 downto 0);
  signal s19: std_logic_vector(15 downto 0);
  signal s20: std_logic_vector(15 downto 0);
  signal s21: std_logic;
  signal s22: std_logic;
  signal s23: std_logic;
  signal s24: std_logic_vector(1 downto 0);
  signal s25: std_logic;
  signal s26: std_logic;
  signal s27: std_logic;
  signal s28: std_logic;
  signal s29: std_logic;
  signal s30: std_logic;
  signal s31: std_logic;
  signal s32: std_logic;
  signal s33: std_logic_vector(15 downto 0);
  signal s34: std_logic;
  signal s35: std_logic;
  signal s36: std_logic;
  signal s37: std_logic_vector(15 downto 0);
  signal s38: std_logic_vector(15 downto 0);
  signal s39: std_logic_vector(15 downto 0);
  signal s40: std_logic_vector(2 downto 0);
  signal s41: std_logic_vector(3 downto 0);
  signal s42: std_logic;
  signal s43: std_logic;
  signal s44: std_logic_vector(15 downto 0);
  signal s45: std_logic_vector(15 downto 0);
  signal s46: std_logic_vector(15 downto 0);
  signal s47: std_logic_vector(2 downto 0);
  signal s48: std_logic_vector(3 downto 0);
  signal s49: std_logic;
  signal s50: std_logic;
  signal s51: std_logic;
  signal s52: std_logic_vector(1 downto 0);
  signal s53: std_logic;
  signal s54: std_logic;
  signal s55: std_logic;
  signal s56: std_logic;
  signal s57: std_logic;
  signal s58: std_logic;
  signal s59: std_logic_vector(15 downto 0);
  signal s60: std_logic_vector(15 downto 0);
  signal s61: std_logic;
  signal s62: std_logic;
  signal s63: std_logic;
  signal s64: std_logic_vector(15 downto 0);
  signal s65: std_logic_vector(15 downto 0);
  signal s66: std_logic;
  signal s67: std_logic;
  signal s68: std_logic;
  signal s69: std_logic_vector(2 downto 0);
  signal s70: std_logic;
  signal s71: std_logic;
  signal s72: std_logic_vector(15 downto 0);
  signal s73: std_logic_vector(15 downto 0);
  signal s74: std_logic_vector(15 downto 0);
  signal s75: std_logic_vector(7 downto 0);
  signal s76: std_logic;
  signal s77: std_logic;
  signal s78: std_logic_vector(3 downto 0);
  signal s79: std_logic_vector(15 downto 0);
  signal s80: std_logic_vector(15 downto 0);
  signal s81: std_logic_vector(1 downto 0);
  signal s82: std_logic_vector(1 downto 0);
  signal s83: std_logic_vector(15 downto 0);
  signal s84: std_logic_vector(15 downto 0);
  signal s85: std_logic_vector(15 downto 0);
  signal s86: std_logic;
  signal s87: std_logic;
begin
  gate0: entity work.DIG_RAMDualAccess -- RAM
    generic map (
      Bits => 16,
      AddrBits => 16)
    port map (
      str => s0,
      C => CLK,
      ld => s1,
      n1A => s2,
      n1Din => s3,
      n2A => s4,
      n1D => s5,
      n2D => s6);
  gate1: entity work.DIG_Register_BUS -- PC
    generic map (
      Bits => 16)
    port map (
      D => s7,
      C => CLK,
      en => s8,
      Q => s4);
  gate2: entity work.DIG_Add -- +1
    generic map (
      Bits => 16)
    port map (
      a => "0000000000000001",
      b => s4,
      c_i => '0',
      s => s9);
  gate3: entity work.reg_file
    port map (
      RS1 => s10,
      RS2 => s11,
      WS => s12,
      WE => s13,
      p_IN => s14,
      CLK => CLK,
      FL_IN => s15,
      FL_EN => s16,
      PC_IN => s7,
      HE => s17,
      OUT1 => s18,
      OUT2 => s19);
  gate4: entity work.control_unit
    port map (
      INST => s20,
      FlagWriteD => s21,
      ALUSrcD => s22,
      BranchD => s23,
      ALUCtrlD => s24,
      MemWriteD => s25,
      MemToRegD => s26,
      RegWriteD => s27,
      PCSrcD => s28,
      SethD => s29,
      FlagEN => s16,
      LDR => s30,
      InsertNOP => s31);
  gate5: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => s32,
      in_0 => s9,
      in_1 => s14,
      p_out => s33);
  gate6: entity work.if_id_ppr
    port map (
      INSN_IN => s6,
      CLK => CLK,
      EN => s34,
      CLR => s35,
      INSN_OUT => s20);
  gate7: entity work.id_ex_ppr
    port map (
      CondD => s36,
      Ra1D => s37,
      Ra2D => s38,
      SEI16D => s39,
      CLK => CLK,
      WAD => s40,
      FlagsD => s41,
      PCSrcD => s28,
      RegWriteD => s27,
      MemToRegD => s26,
      ALUCtrlD => s24,
      BranchD => s23,
      ALUSrcD => s22,
      FlagWriteD => s21,
      MemWriteD => s25,
      LDRD => s30,
      SethD => s29,
      Rd1D => s18,
      Rd2D => s19,
      CLR => s42,
      CondE => s43,
      Ra1E => s44,
      Ra2E => s45,
      SEI16E => s46,
      WAE => s47,
      FlagsE => s48,
      PCSrcE => s49,
      RegWriteE => s50,
      MemToRegE => s51,
      ALUCtrlE => s52,
      BranchE => s53,
      ALUSrcE => s54,
      FlagWriteE => s55,
      MemWriteE => s56,
      LDRE => s57,
      SethE => s58,
      Rd1E => s59,
      Rd2E => s60);
  gate8: entity work.ex_mem_ppr
    port map (
      CLK => CLK,
      PCSrcE => s61,
      RegWriteE => s62,
      MemToRegE => s51,
      MemWriteE => s63,
      ALUResultE => s64,
      WriteDataE => s65,
      WAE => s47,
      LDRE => s57,
      sethE => s58,
      PCSrcM => s66,
      RegWriteM => s67,
      MemToReg => s68,
      MemWriteM => s0,
      ALUResultM => s2,
      WriteDataM => s3,
      WA3M => s69,
      LDRM => s1,
      sethM => s70);
  gate9: entity work.mem_wb_ppr
    port map (
      CLK => CLK,
      PCSrcM => s66,
      RegWriteM => s67,
      MemToRegM => s68,
      ReadDataM => s5,
      ALUResultM => s2,
      WA3M => s69,
      SethM => s70,
      PCSrcW => s32,
      RegWriteW => s13,
      MemToRegW => s71,
      ReadDataW => s72,
      ALUResultW => s73,
      WA3W => s12,
      SethW => s17);
  gate10: entity work.DIG_BitExtender
    generic map (
      inputBits => 8,
      outputBits => 16)
    port map (
      p_in => s75,
      p_out => s39);
  s61 <= (s49 AND s76);
  s62 <= (s50 AND s76);
  s63 <= (s56 AND s76);
  s77 <= (s53 AND s76);
  gate11: entity work.condition_unit
    port map (
      FlagWriteE => s55,
      CondE => s43,
      FlagsE => s48,
      ALUFlags => s78,
      CondExE => s76,
      FlagsM => s41);
  gate12: entity work.alu
    port map (
      A => s79,
      B => s80,
      ALUOP => s52,
      RESULT => s64,
      FLAG => s78);
  gate13: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => s54,
      in_0 => s65,
      in_1 => s46,
      p_out => s80);
  gate14: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => s71,
      in_0 => s73,
      in_1 => s72,
      p_out => s14);
  gate15: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => s31,
      in_0 => s20,
      in_1 => "0000000000000000",
      p_out => s74);
  gate16: entity work.DIG_BitExtender
    generic map (
      inputBits => 4,
      outputBits => 16)
    port map (
      p_in => s41,
      p_out => s15);
  gate17: entity work.MUX_GATE_BUS_2
    generic map (
      Bits => 16)
    port map (
      sel => s81,
      in_0 => s59,
      in_1 => s14,
      in_2 => s2,
      in_3 => "0000000000000000",
      p_out => s79);
  gate18: entity work.MUX_GATE_BUS_2
    generic map (
      Bits => 16)
    port map (
      sel => s82,
      in_0 => s60,
      in_1 => s14,
      in_2 => s2,
      in_3 => "0000000000000000",
      p_out => s65);
  gate19: entity work.hazard_unit
    port map (
      RA1D => s37,
      RA2D => s38,
      WA3E => s83,
      MemtoRegE => s51,
      PCSrcD => s28,
      PCSrcE => s49,
      PCSrcM => s66,
      PCSrcW => s32,
      BranchTakenE => s77,
      RegWriteM => s67,
      RegWriteW => s13,
      RA1E => s44,
      RA2E => s45,
      WA3M => s84,
      WA3W => s85,
      ALUSrcE => s54,
      StallF => s86,
      StallD => s87,
      FlushD => s35,
      FlushE => s42,
      ForwardBE => s82,
      ForwardAE => s81);
  gate20: entity work.reg_address_extender
    port map (
      p_IN => s10,
      p_OUT => s37);
  gate21: entity work.reg_address_extender
    port map (
      p_IN => s11,
      p_OUT => s38);
  gate22: entity work.reg_address_extender
    port map (
      p_IN => s69,
      p_OUT => s84);
  gate23: entity work.reg_address_extender
    port map (
      p_IN => s12,
      p_OUT => s85);
  s8 <= NOT s86;
  gate24: entity work.reg_address_extender
    port map (
      p_IN => s47,
      p_OUT => s83);
  s34 <= NOT s87;
  gate25: entity work.MUX_GATE_BUS_1
    generic map (
      Bits => 16)
    port map (
      sel => s77,
      in_0 => s33,
      in_1 => s64,
      p_out => s7);
  s36 <= s74(11);
  s40 <= s74(10 downto 8);
  s75 <= s74(7 downto 0);
  s10 <= s74(6 downto 4);
  s11 <= s74(2 downto 0);
end Behavioral;

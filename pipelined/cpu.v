/*
 * Generated by Digital. Don't modify this file!
 * Any changes will be lost if this file is regenerated.
 */
module DIG_RAMDualAccess
#(
    parameter Bits = 8,
    parameter AddrBits = 4
)
(
    input C, // Clock signal
    input ld,
    input [(AddrBits-1):0] \1A ,
    input [(AddrBits-1):0] \2A ,
    input [(Bits-1):0] \1Din ,
    input str,
    output [(Bits-1):0] \1D ,
    output [(Bits-1):0] \2D
);
    // CAUTION: uses distributed RAM
    reg [(Bits-1):0] memory [0:((1 << AddrBits)-1)];

    assign \1D = ld? memory[\1A ] : 'hz;
    assign \2D = memory[\2A ];

    always @ (posedge C) begin
        if (str)
            memory[\1A ] <= \1Din ;
    end

endmodule



module DIG_Register_BUS #(
    parameter Bits = 1
)
(
    input C,
    input en,
    input [(Bits - 1):0]D,
    output [(Bits - 1):0]Q
);

    reg [(Bits - 1):0] state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule
module DIG_Add
#(
    parameter Bits = 1
)
(
    input [(Bits-1):0] a,
    input [(Bits-1):0] b,
    input c_i,
    output [(Bits - 1):0] s,
    output c_o
);
   wire [Bits:0] temp;

   assign temp = a + b + c_i;
   assign s = temp [(Bits-1):0];
   assign c_o = temp[Bits];
endmodule



module Demux3
(
    output out_0,
    output out_1,
    output out_2,
    output out_3,
    output out_4,
    output out_5,
    output out_6,
    output out_7,
    input [2:0] sel,
    input in
);
    assign out_0 = (sel == 3'h0)? in : 'd0;
    assign out_1 = (sel == 3'h1)? in : 'd0;
    assign out_2 = (sel == 3'h2)? in : 'd0;
    assign out_3 = (sel == 3'h3)? in : 'd0;
    assign out_4 = (sel == 3'h4)? in : 'd0;
    assign out_5 = (sel == 3'h5)? in : 'd0;
    assign out_6 = (sel == 3'h6)? in : 'd0;
    assign out_7 = (sel == 3'h7)? in : 'd0;
endmodule


module Mux_2x1_NBits #(
    parameter Bits = 2
)
(
    input [0:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module Mux_8x1_NBits #(
    parameter Bits = 2
)
(
    input [2:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    input [(Bits - 1):0] in_4,
    input [(Bits - 1):0] in_5,
    input [(Bits - 1):0] in_6,
    input [(Bits - 1):0] in_7,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            3'h0: out = in_0;
            3'h1: out = in_1;
            3'h2: out = in_2;
            3'h3: out = in_3;
            3'h4: out = in_4;
            3'h5: out = in_5;
            3'h6: out = in_6;
            3'h7: out = in_7;
            default:
                out = 'h0;
        endcase
    end
endmodule


module high_mask_in (
  input [15:0] D_HIGH,
  input [15:0] D,
  input EN,
  output [15:0] Q
);
  wire [15:0] s0;
  assign s0[7:0] = D[7:0];
  assign s0[15:8] = D_HIGH[7:0];
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i0 (
    .sel( EN ),
    .in_0( D_HIGH ),
    .in_1( s0 ),
    .out( Q )
  );
endmodule

module reg_file (
  input [2:0] RS1, // The index of the register which should output its value to OUT1.
  input [2:0] RS2, // The index of the register which should output its value to OUT2.
  input [2:0] WS, // The index of the register which should save the value on IN on the next clock cycle (if WE is high).
  input WE, // Whether the register selected by WS should save the value from IN on the next cycle.
  input [15:0] IN, // The value to be saved into the register specified by WS if WE is high,
  input CLK,
  input [15:0] FL_IN, // The value to be saved into the register specified by WS if WE is high,
  input FL_EN, // Whether the register selected by WS should save the value from IN on the next cycle.
  input [15:0] PC_IN,
  input HE,
  output [15:0] OUT1, // The value in the register specified by RS1.
  output [15:0] OUT2 // The value in the register specified by RS2.

);
  wire [15:0] s0;
  wire s1;
  wire [15:0] s2;
  wire [15:0] s3;
  wire s4;
  wire [15:0] s5;
  wire [15:0] s6;
  wire s7;
  wire [15:0] s8;
  wire [15:0] s9;
  wire s10;
  wire [15:0] s11;
  wire [15:0] s12;
  wire [15:0] s13;
  wire s14;
  wire s15;
  wire [15:0] s16;
  wire s17;
  wire [15:0] s18;
  Demux3 Demux3_i0 (
    .sel( WS ),
    .in( WE ),
    .out_1( s1 ),
    .out_2( s4 ),
    .out_3( s7 ),
    .out_4( s10 ),
    .out_5( s14 ),
    .out_7( s15 )
  );
  assign s17 = (s14 | FL_EN);
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i1 (
    .sel( s15 ),
    .in_0( PC_IN ),
    .in_1( IN ),
    .out( s18 )
  );
  // R1
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i2 (
    .D( s0 ),
    .C( CLK ),
    .en( s1 ),
    .Q( s2 )
  );
  // R2
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i3 (
    .D( s3 ),
    .C( CLK ),
    .en( s4 ),
    .Q( s5 )
  );
  // R3
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i4 (
    .D( s6 ),
    .C( CLK ),
    .en( s7 ),
    .Q( s8 )
  );
  // R4
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i5 (
    .D( s9 ),
    .C( CLK ),
    .en( s10 ),
    .Q( s11 )
  );
  Mux_8x1_NBits #(
    .Bits(16)
  )
  Mux_8x1_NBits_i6 (
    .sel( RS1 ),
    .in_0( 16'b0 ),
    .in_1( s2 ),
    .in_2( s5 ),
    .in_3( s8 ),
    .in_4( s11 ),
    .in_5( s12 ),
    .in_6( 16'b0 ),
    .in_7( s13 ),
    .out( OUT1 )
  );
  Mux_8x1_NBits #(
    .Bits(16)
  )
  Mux_8x1_NBits_i7 (
    .sel( RS2 ),
    .in_0( 16'b0 ),
    .in_1( s2 ),
    .in_2( s5 ),
    .in_3( s8 ),
    .in_4( s11 ),
    .in_5( s12 ),
    .in_6( 16'b0 ),
    .in_7( s13 ),
    .out( OUT2 )
  );
  // FL
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i8 (
    .D( s16 ),
    .C( CLK ),
    .en( s17 ),
    .Q( s12 )
  );
  high_mask_in high_mask_in_i9 (
    .D_HIGH( IN ),
    .D( s2 ),
    .EN( HE ),
    .Q( s0 )
  );
  high_mask_in high_mask_in_i10 (
    .D_HIGH( IN ),
    .D( s5 ),
    .EN( HE ),
    .Q( s3 )
  );
  high_mask_in high_mask_in_i11 (
    .D_HIGH( IN ),
    .D( s8 ),
    .EN( HE ),
    .Q( s6 )
  );
  high_mask_in high_mask_in_i12 (
    .D_HIGH( IN ),
    .D( s11 ),
    .EN( HE ),
    .Q( s9 )
  );
  high_mask_in high_mask_in_i13 (
    .D_HIGH( FL_IN ),
    .D( s12 ),
    .EN( HE ),
    .Q( s16 )
  );
  high_mask_in high_mask_in_i14 (
    .D_HIGH( s18 ),
    .D( s13 ),
    .EN( HE ),
    .Q( s13 )
  );
endmodule

module CompUnsigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = a > b;
    assign \= = a == b;
    assign \< = a < b;
endmodule

module LUT_OpcodeCL (
    input \0 ,
    input \1 ,
    input \2 ,
    input \3 ,
    output reg  [11:0]  out
);
    reg [11:0] my_lut [0:15];
    wire [3:0] temp;
    assign temp = {\3 , \2 , \1 , \0 };

    always @ (*) begin
       out = my_lut[temp];
    end

    initial begin
        my_lut[0] = 12'h410;
        my_lut[1] = 12'h414;
        my_lut[2] = 12'h0;
        my_lut[3] = 12'h0;
        my_lut[4] = 12'h100;
        my_lut[5] = 12'h601;
        my_lut[6] = 12'h0;
        my_lut[7] = 12'h0;
        my_lut[8] = 12'h40a;
        my_lut[9] = 12'h44a;
        my_lut[10] = 12'h48a;
        my_lut[11] = 12'h4ca;
        my_lut[12] = 12'h0;
        my_lut[13] = 12'h0;
        my_lut[14] = 12'h0;
        my_lut[15] = 12'h0;
    end
endmodule


module Mux_2x1
(
    input [0:0] sel,
    input in_0,
    input in_1,
    output reg out
);
    always @ (*) begin
        case (sel)
            1'h0: out = in_0;
            1'h1: out = in_1;
            default:
                out = 'h0;
        endcase
    end
endmodule


module control_unit (
  input [15:0] INST,
  output FlagWriteD,
  output ALUSrcD,
  output BranchD,
  output [1:0] ALUCtrlD,
  output MemWriteD,
  output MemToRegD,
  output RegWriteD,
  output PCSrcD,
  output SethD,
  output FlagEN,
  output LDR,
  output InsertNOP
);
  wire [2:0] s0;
  wire [3:0] s1;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire [11:0] s6;
  wire s7;
  wire s8;
  wire s9;
  wire [1:0] s10;
  wire s11;
  wire s12;
  wire s13;
  wire s14;
  wire s15;
  wire s16;
  wire InsertNOP_temp;
  wire s17;
  wire [1:0] s18;
  wire s19;
  assign s18[0] = 1'b0;
  assign s18[1] = 1'b0;
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i0 (
    .a( 16'b0 ),
    .b( INST ),
    .\= ( InsertNOP_temp )
  );
  assign s0 = INST[10:8];
  assign s1 = INST[15:12];
  // Is Rd PC
  CompUnsigned #(
    .Bits(3)
  )
  CompUnsigned_i1 (
    .a( s0 ),
    .b( 3'b111 ),
    .\= ( s16 )
  );
  assign s2 = s1[0];
  assign s3 = s1[1];
  assign s4 = s1[2];
  assign s5 = s1[3];
  // OpcodeCL
  LUT_OpcodeCL LUT_OpcodeCL_i2 (
    .\0 ( s2 ),
    .\1 ( s3 ),
    .\2 ( s4 ),
    .\3 ( s5 ),
    .out( s6 )
  );
  assign s17 = (s16 | s6[11]);
  assign s19 = (s16 | s6[5]);
  assign s7 = s6[10];
  assign s8 = s6[9];
  assign s9 = s6[8];
  assign s10 = s6[7:6];
  assign s11 = s6[4];
  assign s12 = s6[3];
  assign s13 = s6[2];
  assign s14 = s6[1];
  assign s15 = s6[0];
  Mux_2x1 Mux_2x1_i3 (
    .sel( InsertNOP_temp ),
    .in_0( s17 ),
    .in_1( 1'b0 ),
    .out( PCSrcD )
  );
  Mux_2x1 Mux_2x1_i4 (
    .sel( InsertNOP_temp ),
    .in_0( s7 ),
    .in_1( 1'b0 ),
    .out( RegWriteD )
  );
  Mux_2x1 Mux_2x1_i5 (
    .sel( InsertNOP_temp ),
    .in_0( s8 ),
    .in_1( 1'b0 ),
    .out( MemToRegD )
  );
  Mux_2x1 Mux_2x1_i6 (
    .sel( InsertNOP_temp ),
    .in_0( s9 ),
    .in_1( 1'b0 ),
    .out( MemWriteD )
  );
  Mux_2x1_NBits #(
    .Bits(2)
  )
  Mux_2x1_NBits_i7 (
    .sel( InsertNOP_temp ),
    .in_0( s10 ),
    .in_1( s18 ),
    .out( ALUCtrlD )
  );
  Mux_2x1 Mux_2x1_i8 (
    .sel( InsertNOP_temp ),
    .in_0( s19 ),
    .in_1( 1'b0 ),
    .out( BranchD )
  );
  Mux_2x1 Mux_2x1_i9 (
    .sel( InsertNOP_temp ),
    .in_0( s11 ),
    .in_1( 1'b0 ),
    .out( ALUSrcD )
  );
  Mux_2x1 Mux_2x1_i10 (
    .sel( InsertNOP_temp ),
    .in_0( s12 ),
    .in_1( 1'b0 ),
    .out( FlagWriteD )
  );
  Mux_2x1 Mux_2x1_i11 (
    .sel( InsertNOP_temp ),
    .in_0( s13 ),
    .in_1( 1'b0 ),
    .out( SethD )
  );
  Mux_2x1 Mux_2x1_i12 (
    .sel( InsertNOP_temp ),
    .in_0( s14 ),
    .in_1( 1'b0 ),
    .out( FlagEN )
  );
  Mux_2x1 Mux_2x1_i13 (
    .sel( InsertNOP_temp ),
    .in_0( s15 ),
    .in_1( 1'b0 ),
    .out( LDR )
  );
  assign InsertNOP = InsertNOP_temp;
endmodule

module if_id_ppr (
  input [15:0] INSN_IN,
  input CLK,
  input EN,
  input CLR,
  output [15:0] INSN_OUT
);
  wire [15:0] s0;
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i0 (
    .sel( CLR ),
    .in_0( INSN_IN ),
    .in_1( 16'b0 ),
    .out( s0 )
  );
  // INSN
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i1 (
    .D( s0 ),
    .C( CLK ),
    .en( EN ),
    .Q( INSN_OUT )
  );
endmodule

module DIG_Register
(
    input C,
    input en,
    input D,
    output Q
);

    reg  state = 'h0;

    assign Q = state;

    always @ (posedge C) begin
        if (en)
            state <= D;
   end
endmodule

module id_ex_ppr (
  input CondD,
  input [15:0] Ra1D,
  input [15:0] Ra2D,
  input [15:0] SEI16D,
  input CLK,
  input [2:0] WAD,
  input [3:0] FlagsD,
  input PCSrcD,
  input RegWriteD,
  input MemToRegD,
  input [1:0] ALUCtrlD,
  input BranchD,
  input ALUSrcD,
  input FlagWriteD,
  input MemWriteD,
  input LDRD,
  input SethD,
  input [15:0] Rd1D,
  input [15:0] Rd2D,
  input CLR,
  output CondE,
  output [15:0] Ra1E,
  output [15:0] Ra2E,
  output [15:0] SEI16E,
  output [2:0] WAE,
  output [3:0] FlagsE,
  output PCSrcE,
  output RegWriteE,
  output MemToRegE,
  output [1:0] ALUCtrlE,
  output BranchE,
  output ALUSrcE,
  output FlagWriteE,
  output MemWriteE,
  output LDRE,
  output SethE,
  output [15:0] Rd1E,
  output [15:0] Rd2E
);
  wire [15:0] s0;
  wire [15:0] s1;
  wire [15:0] s2;
  wire [2:0] s3;
  wire [15:0] s4;
  wire [15:0] s5;
  // Cond
  DIG_Register DIG_Register_i0 (
    .D( CondD ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( CondE )
  );
  // Flags
  DIG_Register_BUS #(
    .Bits(4)
  )
  DIG_Register_BUS_i1 (
    .D( FlagsD ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( FlagsE )
  );
  // PCSrc
  DIG_Register DIG_Register_i2 (
    .D( PCSrcD ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( PCSrcE )
  );
  // RegWrite
  DIG_Register DIG_Register_i3 (
    .D( RegWriteD ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( RegWriteE )
  );
  // MemToReg
  DIG_Register DIG_Register_i4 (
    .D( MemToRegD ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( MemToRegE )
  );
  // ALUCtrl
  DIG_Register_BUS #(
    .Bits(2)
  )
  DIG_Register_BUS_i5 (
    .D( ALUCtrlD ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( ALUCtrlE )
  );
  // BranchD
  DIG_Register DIG_Register_i6 (
    .D( BranchD ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( BranchE )
  );
  // ALUSrc
  DIG_Register DIG_Register_i7 (
    .D( ALUSrcD ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( ALUSrcE )
  );
  // FlagWrite
  DIG_Register DIG_Register_i8 (
    .D( FlagWriteD ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( FlagWriteE )
  );
  // MemWrite
  DIG_Register DIG_Register_i9 (
    .D( MemWriteD ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( MemWriteE )
  );
  // LDR
  DIG_Register DIG_Register_i10 (
    .D( LDRD ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( LDRE )
  );
  // SethD
  DIG_Register DIG_Register_i11 (
    .D( SethD ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( SethE )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i12 (
    .sel( CLR ),
    .in_0( Rd2D ),
    .in_1( 16'b0 ),
    .out( s5 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i13 (
    .sel( CLR ),
    .in_0( Rd1D ),
    .in_1( 16'b0 ),
    .out( s4 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i14 (
    .sel( CLR ),
    .in_0( Ra2D ),
    .in_1( 16'b0 ),
    .out( s1 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i15 (
    .sel( CLR ),
    .in_0( Ra1D ),
    .in_1( 16'b0 ),
    .out( s0 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i16 (
    .sel( CLR ),
    .in_0( SEI16D ),
    .in_1( 16'b0 ),
    .out( s2 )
  );
  Mux_2x1_NBits #(
    .Bits(3)
  )
  Mux_2x1_NBits_i17 (
    .sel( CLR ),
    .in_0( WAD ),
    .in_1( 3'b0 ),
    .out( s3 )
  );
  // Ra1
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i18 (
    .D( s0 ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( Ra1E )
  );
  // Ra2
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i19 (
    .D( s1 ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( Ra2E )
  );
  // SEI16
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i20 (
    .D( s2 ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( SEI16E )
  );
  // WA
  DIG_Register_BUS #(
    .Bits(3)
  )
  DIG_Register_BUS_i21 (
    .D( s3 ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( WAE )
  );
  // Rd1
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i22 (
    .D( s4 ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( Rd1E )
  );
  // Rd2
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i23 (
    .D( s5 ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( Rd2E )
  );
endmodule

module ex_mem_ppr (
  input CLK,
  input PCSrcE,
  input RegWriteE,
  input MemToRegE,
  input MemWriteE,
  input [15:0] ALUResultE,
  input [15:0] WriteDataE,
  input [2:0] WAE,
  input LDRE,
  input sethE,
  output PCSrcM,
  output RegWriteM,
  output MemToReg,
  output MemWriteM,
  output [15:0] ALUResultM,
  output [15:0] WriteDataM,
  output [2:0] WA3M,
  output LDRM,
  output sethM
);
  // PCSrc
  DIG_Register DIG_Register_i0 (
    .D( PCSrcE ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( PCSrcM )
  );
  // RegWrite
  DIG_Register DIG_Register_i1 (
    .D( RegWriteE ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( RegWriteM )
  );
  // MemToReg
  DIG_Register DIG_Register_i2 (
    .D( MemToRegE ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( MemToReg )
  );
  // MemWrite
  DIG_Register DIG_Register_i3 (
    .D( MemWriteE ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( MemWriteM )
  );
  // ALUResult
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i4 (
    .D( ALUResultE ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( ALUResultM )
  );
  // WriteData
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i5 (
    .D( WriteDataE ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( WriteDataM )
  );
  // WA
  DIG_Register_BUS #(
    .Bits(3)
  )
  DIG_Register_BUS_i6 (
    .D( WAE ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( WA3M )
  );
  // LDR
  DIG_Register DIG_Register_i7 (
    .D( LDRE ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( LDRM )
  );
  // setHE
  DIG_Register DIG_Register_i8 (
    .D( sethE ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( sethM )
  );
endmodule

module mem_wb_ppr (
  input CLK,
  input PCSrcM,
  input RegWriteM,
  input MemToRegM,
  input [15:0] ReadDataM,
  input [15:0] ALUResultM,
  input [2:0] WA3M,
  input SethM,
  output PCSrcW,
  output RegWriteW,
  output MemToRegW,
  output [15:0] ReadDataW,
  output [15:0] ALUResultW,
  output [2:0] WA3W,
  output SethW
);
  // PCSrc
  DIG_Register DIG_Register_i0 (
    .D( PCSrcM ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( PCSrcW )
  );
  // RegWrite
  DIG_Register DIG_Register_i1 (
    .D( RegWriteM ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( RegWriteW )
  );
  // MemToReg
  DIG_Register DIG_Register_i2 (
    .D( MemToRegM ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( MemToRegW )
  );
  // ReadData
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i3 (
    .D( ReadDataM ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( ReadDataW )
  );
  // ALUResult
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i4 (
    .D( ALUResultM ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( ALUResultW )
  );
  // WA3
  DIG_Register_BUS #(
    .Bits(3)
  )
  DIG_Register_BUS_i5 (
    .D( WA3M ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( WA3W )
  );
  // Seth
  DIG_Register DIG_Register_i6 (
    .D( SethM ),
    .C( CLK ),
    .en( 1'b1 ),
    .Q( SethW )
  );
endmodule
module DIG_BitExtender #(
    parameter inputBits = 2,
    parameter outputBits = 4
)
(
    input [(inputBits-1):0] in,
    output [(outputBits - 1):0] out
);
    assign out = {{(outputBits - inputBits){in[inputBits - 1]}}, in};
endmodule




module condition_unit (
  input FlagWriteE,
  input CondE,
  input [3:0] FlagsE,
  input [3:0] ALUFlags,
  output CondExE,
  output [3:0] FlagsM
);
  Mux_2x1_NBits #(
    .Bits(4)
  )
  Mux_2x1_NBits_i0 (
    .sel( FlagWriteE ),
    .in_0( FlagsE ),
    .in_1( ALUFlags ),
    .out( FlagsM )
  );
  assign CondExE = (FlagsE[0] | ~ CondE);
endmodule

module CompSigned #(
    parameter Bits = 1
)
(
    input [(Bits -1):0] a,
    input [(Bits -1):0] b,
    output \> ,
    output \= ,
    output \<
);
    assign \> = $signed(a) > $signed(b);
    assign \= = $signed(a) == $signed(b);
    assign \< = $signed(a) < $signed(b);
endmodule


module ripple_carry_adder_overflow (
  input [15:0] A,
  input [15:0] B,
  input C_in,
  output [15:0] Q,
  output C_out,
  output V
);
  wire [14:0] s0;
  wire [14:0] s1;
  wire [14:0] s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire C_out_temp;
  assign s0 = A[14:0];
  assign s4 = A[15];
  assign s1 = B[14:0];
  assign s5 = B[15];
  DIG_Add #(
    .Bits(15)
  )
  DIG_Add_i0 (
    .a( s0 ),
    .b( s1 ),
    .c_i( C_in ),
    .s( s2 ),
    .c_o( s3 )
  );
  DIG_Add #(
    .Bits(1)
  )
  DIG_Add_i1 (
    .a( s4 ),
    .b( s5 ),
    .c_i( s3 ),
    .s( s6 ),
    .c_o( C_out_temp )
  );
  assign Q[14:0] = s2;
  assign Q[15] = s6;
  assign V = (C_out_temp ^ s3);
  assign C_out = C_out_temp;
endmodule

module Mux_4x1_NBits #(
    parameter Bits = 2
)
(
    input [1:0] sel,
    input [(Bits - 1):0] in_0,
    input [(Bits - 1):0] in_1,
    input [(Bits - 1):0] in_2,
    input [(Bits - 1):0] in_3,
    output reg [(Bits - 1):0] out
);
    always @ (*) begin
        case (sel)
            2'h0: out = in_0;
            2'h1: out = in_1;
            2'h2: out = in_2;
            2'h3: out = in_3;
            default:
                out = 'h0;
        endcase
    end
endmodule


module alu (
  input [15:0] A, // First input to ALU
  input [15:0] B, // Second input to ALU
  input [1:0] ALUOP, // Operation selection input
  output [15:0] RESULT, // The result of this ALU operation
  output [3:0] FLAG // The flags associated with the result of this ALU operation
                    // 
                    // 0. Z (zero)
                    // 1. N (negative)
                    // 2. C (carry)
                    // 3. V (overflow)

);
  wire [15:0] RESULT_temp;
  wire [15:0] s0;
  wire s1;
  wire [15:0] s2;
  wire [15:0] s3;
  wire [15:0] s4;
  wire [15:0] s5;
  wire s6;
  wire s7;
  wire s8;
  wire s9;
  wire s10;
  wire C_out;
  wire V;
  assign s0 = ~ B;
  CompSigned #(
    .Bits(2)
  )
  CompSigned_i0 (
    .a( 2'b1 ),
    .b( ALUOP ),
    .\= ( s1 )
  );
  assign s10 = ALUOP[1];
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i1 (
    .sel( s1 ),
    .in_0( B ),
    .in_1( s0 ),
    .out( s2 )
  );
  assign s3 = (A | s2);
  assign s5 = (A & s2);
  ripple_carry_adder_overflow ripple_carry_adder_overflow_i2 (
    .A( A ),
    .B( s2 ),
    .C_in( s1 ),
    .Q( s4 ),
    .C_out( C_out ),
    .V( V )
  );
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i3 (
    .sel( ALUOP ),
    .in_0( s4 ),
    .in_1( s4 ),
    .in_2( s5 ),
    .in_3( s3 ),
    .out( RESULT_temp )
  );
  Mux_2x1 Mux_2x1_i4 (
    .sel( s10 ),
    .in_0( C_out ),
    .in_1( 1'b0 ),
    .out( s8 )
  );
  Mux_2x1 Mux_2x1_i5 (
    .sel( s10 ),
    .in_0( V ),
    .in_1( 1'b0 ),
    .out( s9 )
  );
  CompSigned #(
    .Bits(16)
  )
  CompSigned_i6 (
    .a( RESULT_temp ),
    .b( 16'b0 ),
    .\= ( s6 ),
    .\< ( s7 )
  );
  assign FLAG[0] = s6;
  assign FLAG[1] = s7;
  assign FLAG[2] = s8;
  assign FLAG[3] = s9;
  assign RESULT = RESULT_temp;
endmodule

module data_hazard_forwarding (
  input I_3,
  input I_2,
  input I_1,
  input I_0,
  output [1:0] ForwardE
);
  assign ForwardE[0] = ((I_3 & ~ I_1 & I_0) | (I_3 & ~ I_2 & I_0));
  assign ForwardE[1] = (I_2 & I_1);
endmodule

module hazard_unit (
  input [15:0] RA1D,
  input [15:0] RA2D,
  input [15:0] WA3E,
  input MemtoRegE,
  input PCSrcD,
  input PCSrcE,
  input PCSrcM,
  input PCSrcW,
  input BranchTakenE,
  input RegWriteM,
  input RegWriteW,
  input [15:0] RA1E,
  input [15:0] RA2E,
  input [15:0] WA3M,
  input [15:0] WA3W,
  input ALUSrcE,
  output StallF,
  output StallD,
  output FlushD,
  output FlushE,
  output [1:0] ForwardBE,
  output [1:0] ForwardAE
);
  wire s0;
  wire s1;
  wire StallD_temp;
  wire s2;
  wire s3;
  wire s4;
  wire s5;
  wire s6;
  wire [1:0] s7;
  wire [1:0] s8;
  wire s9;
  wire s10;
  wire s11;
  wire s12;
  // Match1D_E
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i0 (
    .a( RA1D ),
    .b( WA3E ),
    .\= ( s0 )
  );
  // Match2DE
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i1 (
    .a( RA2D ),
    .b( WA3E ),
    .\= ( s1 )
  );
  assign s2 = (PCSrcM | PCSrcE | PCSrcD);
  // Match1_EM
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i2 (
    .a( WA3M ),
    .b( RA1E ),
    .\= ( s3 )
  );
  // Match1_EW
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i3 (
    .a( WA3W ),
    .b( RA1E ),
    .\= ( s4 )
  );
  // Match2_EM
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i4 (
    .a( WA3M ),
    .b( RA2E ),
    .\= ( s5 )
  );
  // Match2_EW
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i5 (
    .a( WA3W ),
    .b( RA2E ),
    .\= ( s6 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i6 (
    .a( RA2E ),
    .b( 16'b0 ),
    .\< ( s11 )
  );
  CompUnsigned #(
    .Bits(16)
  )
  CompUnsigned_i7 (
    .a( RA1E ),
    .b( 16'b0 ),
    .\< ( s12 )
  );
  assign StallD_temp = ((s0 | s1) & MemtoRegE);
  assign FlushD = (PCSrcW | s2 | BranchTakenE);
  data_hazard_forwarding data_hazard_forwarding_i8 (
    .I_3( s4 ),
    .I_2( s3 ),
    .I_1( RegWriteM ),
    .I_0( RegWriteW ),
    .ForwardE( s7 )
  );
  data_hazard_forwarding data_hazard_forwarding_i9 (
    .I_3( s6 ),
    .I_2( s5 ),
    .I_1( RegWriteM ),
    .I_0( RegWriteW ),
    .ForwardE( s8 )
  );
  assign s9 = (s12 | ALUSrcE);
  assign s10 = (s11 | ALUSrcE);
  assign StallF = (s2 | StallD_temp);
  assign FlushE = (BranchTakenE | StallD_temp);
  Mux_2x1_NBits #(
    .Bits(2)
  )
  Mux_2x1_NBits_i10 (
    .sel( s9 ),
    .in_0( s7 ),
    .in_1( 2'b0 ),
    .out( ForwardAE )
  );
  Mux_2x1_NBits #(
    .Bits(2)
  )
  Mux_2x1_NBits_i11 (
    .sel( s10 ),
    .in_0( s8 ),
    .in_1( 2'b0 ),
    .out( ForwardBE )
  );
  assign StallD = StallD_temp;
endmodule

module reg_address_extender (
  input [2:0] IN,
  output [15:0] OUT
);
  assign OUT[2:0] = IN;
  assign OUT[15:3] = 13'b0;
endmodule

module cpu (
  input CLK
);
  wire s0;
  wire s1;
  wire [15:0] s2;
  wire [15:0] s3;
  wire [15:0] s4;
  wire [15:0] s5;
  wire [15:0] s6;
  wire [15:0] s7;
  wire s8;
  wire [15:0] s9;
  wire [2:0] s10;
  wire [2:0] s11;
  wire [2:0] s12;
  wire s13;
  wire [15:0] s14;
  wire [15:0] s15;
  wire s16;
  wire s17;
  wire [15:0] s18;
  wire [15:0] s19;
  wire [15:0] s20;
  wire s21;
  wire s22;
  wire s23;
  wire [1:0] s24;
  wire s25;
  wire s26;
  wire s27;
  wire s28;
  wire s29;
  wire s30;
  wire s31;
  wire s32;
  wire [15:0] s33;
  wire s34;
  wire s35;
  wire s36;
  wire [15:0] s37;
  wire [15:0] s38;
  wire [15:0] s39;
  wire [2:0] s40;
  wire [3:0] s41;
  wire s42;
  wire s43;
  wire [15:0] s44;
  wire [15:0] s45;
  wire [15:0] s46;
  wire [2:0] s47;
  wire [3:0] s48;
  wire s49;
  wire s50;
  wire s51;
  wire [1:0] s52;
  wire s53;
  wire s54;
  wire s55;
  wire s56;
  wire s57;
  wire s58;
  wire [15:0] s59;
  wire [15:0] s60;
  wire s61;
  wire s62;
  wire s63;
  wire [15:0] s64;
  wire [15:0] s65;
  wire s66;
  wire s67;
  wire s68;
  wire [2:0] s69;
  wire s70;
  wire s71;
  wire [15:0] s72;
  wire [15:0] s73;
  wire [15:0] s74;
  wire [7:0] s75;
  wire s76;
  wire s77;
  wire [3:0] s78;
  wire [15:0] s79;
  wire [15:0] s80;
  wire [1:0] s81;
  wire [1:0] s82;
  wire [15:0] s83;
  wire [15:0] s84;
  wire [15:0] s85;
  wire s86;
  wire s87;
  // RAM
  DIG_RAMDualAccess #(
    .Bits(16),
    .AddrBits(16)
  )
  DIG_RAMDualAccess_i0 (
    .str( s0 ),
    .C( CLK ),
    .ld( s1 ),
    .\1A ( s2 ),
    .\1Din ( s3 ),
    .\2A ( s4 ),
    .\1D ( s5 ),
    .\2D ( s6 )
  );
  // PC
  DIG_Register_BUS #(
    .Bits(16)
  )
  DIG_Register_BUS_i1 (
    .D( s7 ),
    .C( CLK ),
    .en( s8 ),
    .Q( s4 )
  );
  // +1
  DIG_Add #(
    .Bits(16)
  )
  DIG_Add_i2 (
    .a( 16'b1 ),
    .b( s4 ),
    .c_i( 1'b0 ),
    .s( s9 )
  );
  reg_file reg_file_i3 (
    .RS1( s10 ),
    .RS2( s11 ),
    .WS( s12 ),
    .WE( s13 ),
    .IN( s14 ),
    .CLK( CLK ),
    .FL_IN( s15 ),
    .FL_EN( s16 ),
    .PC_IN( s7 ),
    .HE( s17 ),
    .OUT1( s18 ),
    .OUT2( s19 )
  );
  control_unit control_unit_i4 (
    .INST( s20 ),
    .FlagWriteD( s21 ),
    .ALUSrcD( s22 ),
    .BranchD( s23 ),
    .ALUCtrlD( s24 ),
    .MemWriteD( s25 ),
    .MemToRegD( s26 ),
    .RegWriteD( s27 ),
    .PCSrcD( s28 ),
    .SethD( s29 ),
    .FlagEN( s16 ),
    .LDR( s30 ),
    .InsertNOP( s31 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i5 (
    .sel( s32 ),
    .in_0( s9 ),
    .in_1( s14 ),
    .out( s33 )
  );
  if_id_ppr if_id_ppr_i6 (
    .INSN_IN( s6 ),
    .CLK( CLK ),
    .EN( s34 ),
    .CLR( s35 ),
    .INSN_OUT( s20 )
  );
  id_ex_ppr id_ex_ppr_i7 (
    .CondD( s36 ),
    .Ra1D( s37 ),
    .Ra2D( s38 ),
    .SEI16D( s39 ),
    .CLK( CLK ),
    .WAD( s40 ),
    .FlagsD( s41 ),
    .PCSrcD( s28 ),
    .RegWriteD( s27 ),
    .MemToRegD( s26 ),
    .ALUCtrlD( s24 ),
    .BranchD( s23 ),
    .ALUSrcD( s22 ),
    .FlagWriteD( s21 ),
    .MemWriteD( s25 ),
    .LDRD( s30 ),
    .SethD( s29 ),
    .Rd1D( s18 ),
    .Rd2D( s19 ),
    .CLR( s42 ),
    .CondE( s43 ),
    .Ra1E( s44 ),
    .Ra2E( s45 ),
    .SEI16E( s46 ),
    .WAE( s47 ),
    .FlagsE( s48 ),
    .PCSrcE( s49 ),
    .RegWriteE( s50 ),
    .MemToRegE( s51 ),
    .ALUCtrlE( s52 ),
    .BranchE( s53 ),
    .ALUSrcE( s54 ),
    .FlagWriteE( s55 ),
    .MemWriteE( s56 ),
    .LDRE( s57 ),
    .SethE( s58 ),
    .Rd1E( s59 ),
    .Rd2E( s60 )
  );
  ex_mem_ppr ex_mem_ppr_i8 (
    .CLK( CLK ),
    .PCSrcE( s61 ),
    .RegWriteE( s62 ),
    .MemToRegE( s51 ),
    .MemWriteE( s63 ),
    .ALUResultE( s64 ),
    .WriteDataE( s65 ),
    .WAE( s47 ),
    .LDRE( s57 ),
    .sethE( s58 ),
    .PCSrcM( s66 ),
    .RegWriteM( s67 ),
    .MemToReg( s68 ),
    .MemWriteM( s0 ),
    .ALUResultM( s2 ),
    .WriteDataM( s3 ),
    .WA3M( s69 ),
    .LDRM( s1 ),
    .sethM( s70 )
  );
  mem_wb_ppr mem_wb_ppr_i9 (
    .CLK( CLK ),
    .PCSrcM( s66 ),
    .RegWriteM( s67 ),
    .MemToRegM( s68 ),
    .ReadDataM( s5 ),
    .ALUResultM( s2 ),
    .WA3M( s69 ),
    .SethM( s70 ),
    .PCSrcW( s32 ),
    .RegWriteW( s13 ),
    .MemToRegW( s71 ),
    .ReadDataW( s72 ),
    .ALUResultW( s73 ),
    .WA3W( s12 ),
    .SethW( s17 )
  );
  DIG_BitExtender #(
    .inputBits(8),
    .outputBits(16)
  )
  DIG_BitExtender_i10 (
    .in( s75 ),
    .out( s39 )
  );
  assign s61 = (s49 & s76);
  assign s62 = (s50 & s76);
  assign s63 = (s56 & s76);
  assign s77 = (s53 & s76);
  condition_unit condition_unit_i11 (
    .FlagWriteE( s55 ),
    .CondE( s43 ),
    .FlagsE( s48 ),
    .ALUFlags( s78 ),
    .CondExE( s76 ),
    .FlagsM( s41 )
  );
  alu alu_i12 (
    .A( s79 ),
    .B( s80 ),
    .ALUOP( s52 ),
    .RESULT( s64 ),
    .FLAG( s78 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i13 (
    .sel( s54 ),
    .in_0( s65 ),
    .in_1( s46 ),
    .out( s80 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i14 (
    .sel( s71 ),
    .in_0( s73 ),
    .in_1( s72 ),
    .out( s14 )
  );
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i15 (
    .sel( s31 ),
    .in_0( s20 ),
    .in_1( 16'b0 ),
    .out( s74 )
  );
  DIG_BitExtender #(
    .inputBits(4),
    .outputBits(16)
  )
  DIG_BitExtender_i16 (
    .in( s41 ),
    .out( s15 )
  );
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i17 (
    .sel( s81 ),
    .in_0( s59 ),
    .in_1( s14 ),
    .in_2( s2 ),
    .in_3( 16'b0 ),
    .out( s79 )
  );
  Mux_4x1_NBits #(
    .Bits(16)
  )
  Mux_4x1_NBits_i18 (
    .sel( s82 ),
    .in_0( s60 ),
    .in_1( s14 ),
    .in_2( s2 ),
    .in_3( 16'b0 ),
    .out( s65 )
  );
  hazard_unit hazard_unit_i19 (
    .RA1D( s37 ),
    .RA2D( s38 ),
    .WA3E( s83 ),
    .MemtoRegE( s51 ),
    .PCSrcD( s28 ),
    .PCSrcE( s49 ),
    .PCSrcM( s66 ),
    .PCSrcW( s32 ),
    .BranchTakenE( s77 ),
    .RegWriteM( s67 ),
    .RegWriteW( s13 ),
    .RA1E( s44 ),
    .RA2E( s45 ),
    .WA3M( s84 ),
    .WA3W( s85 ),
    .ALUSrcE( s54 ),
    .StallF( s86 ),
    .StallD( s87 ),
    .FlushD( s35 ),
    .FlushE( s42 ),
    .ForwardBE( s82 ),
    .ForwardAE( s81 )
  );
  reg_address_extender reg_address_extender_i20 (
    .IN( s10 ),
    .OUT( s37 )
  );
  reg_address_extender reg_address_extender_i21 (
    .IN( s11 ),
    .OUT( s38 )
  );
  reg_address_extender reg_address_extender_i22 (
    .IN( s69 ),
    .OUT( s84 )
  );
  reg_address_extender reg_address_extender_i23 (
    .IN( s12 ),
    .OUT( s85 )
  );
  assign s8 = ~ s86;
  reg_address_extender reg_address_extender_i24 (
    .IN( s47 ),
    .OUT( s83 )
  );
  assign s34 = ~ s87;
  Mux_2x1_NBits #(
    .Bits(16)
  )
  Mux_2x1_NBits_i25 (
    .sel( s77 ),
    .in_0( s33 ),
    .in_1( s64 ),
    .out( s7 )
  );
  assign s36 = s74[11];
  assign s40 = s74[10:8];
  assign s75 = s74[7:0];
  assign s10 = s74[6:4];
  assign s11 = s74[2:0];
endmodule
